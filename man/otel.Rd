% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/otel.R
\name{with_ospan_async}
\alias{with_ospan_async}
\alias{with_ospan_promise_domain}
\alias{create_ospan}
\alias{end_ospan}
\title{\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}} OpenTelemetry integration}
\usage{
with_ospan_async(name, expr, ..., tracer = NULL, attributes = NULL)

with_ospan_promise_domain(expr)

create_ospan(name, ..., tracer = NULL, attributes = NULL)

end_ospan(span)
}
\arguments{
\item{name}{Character string. The name of the span.}

\item{expr}{An expression to evaluate within the span context.}

\item{...}{Additional arguments passed to \code{\link[otel:start_span]{otel::start_span()}}.}

\item{tracer}{An \code{{otel}} tracer. If not provided, code will be executed
under a \code{{promises}} package tracer. It is strongly recommended to provide
your own tracer from your own package. See \code{\link[otel:get_tracer]{otel::get_tracer()}} for more
details.}

\item{attributes}{Attributes passed through \code{\link[otel:as_attributes]{otel::as_attributes()}} (when
not \code{NULL})}
}
\description{
\pkg{otel} provides tools for integrating with OpenTelemetry, a framework for
observability and tracing in distributed systems.

These methods are intended to enhance the framework to be used with the
\pkg{promises} package, not as a generic replacement.

Dev note - Barret 2025/09: This ospan handoff promise domain topic is complex
and has been discussed over many hours. As even advanced Shiny/R developers
are not even aware of promise domains, this topic requires more in-depth
documentation and examples.
}
\section{Functions}{
\itemize{
\item \code{with_ospan_async()}: \ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

Creates an OpenTelemetry span, executes the given expression within it, and
ends the span. This method requires the use of \code{with_ospan_promise_domain()}
to be within the execution stack.

This function is designed to handle both synchronous and asynchronous
(promise-based) operations. For promises, the span is automatically ended
when the promise resolves or rejects.

Returns the result of evaluating \code{expr}. If \code{expr} returns a promise, the
span will be automatically ended when the promise completes.

This function differs from synchronous otel span operations in that it
installs a promise domain and properly handles asynchronous operations. In
addition, the internal span will be ended either when the function exits (for
synchronous operations) or when a returned promise completes (for
asynchronous operations).

If OpenTelemetry is not enabled, the expression will be evaluated without any
tracing context.

\item \code{with_ospan_promise_domain()}: \ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

Adds a handoff "Active OpenTelemetry promise domain" for the expression.

Package authors are required to use this function to have otel span context
persist across asynchronous boundaries. It is important to leverage this
function only once within the execution domain, not recursively / many times.

This method adds a \emph{handoff} "Active OpenTelemetry promise domain" to the
expression evaluation. This \emph{handoff} promise domain will only run once on
reactivation. This is critical if there are many layered \code{with_ospan_async()}
calls, such as within Shiny reactivity. For example, if we nested many
\code{with_ospan_async()} that added a domain which reactivated each ospan on
restore, we'd reactive \code{k} ospan objects (\code{O(k)}) when we only need to
activate the \strong{last} span (\code{O(1)}).

\item \code{create_ospan()}: \ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

Creates an OpenTelemetry span for discontiguous operations where you need
manual control over when the span ends.

Note, the created span is not activated. Please use \code{\link[=with_ospan_async]{with_ospan_async()}} to
activate it for the supplied expression.

Returns an \pkg{otel} span object.

\item \code{end_ospan()}: \ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

Ends an created OpenTelemetry span for discontiguous operations.

}}
\section{Execution model for with_ospan_promise_domain()}{

\subsection{Definitions}{
\itemize{
\item Promise domain: An environment in which has setup/teardown methods. These
environments can be composed together to facilitate execution context for
promises. In normal R execution, this can be achieved with scope / stack.
But for complex situations, such as the currently open graphics device,
async operations require promise domains to setup/teardown these contexts
to function properly. Otherwise a multi-stage promise that adds to the
graphics device at each stage will only ever print to the most recently
created graphics device, not the associated graphics device. These promise
domains are not automatically created, they must be manually added to the
execution stack, for example \code{with_ospan_promise_domain()} does this for
OpenTelemetry spans ("ospan").
\item Promise domain restoration: When switching from one promise chain to
another, the execution context is torn down and then re-established. This
re-establishment is called "promise domain restoration". During this
process, the promise domains are restored in their previously established
combination order.
\item Promise chain: A set of promise objects to execute over multiple async
ticks.
\item Async tick: the number of times an event loop must run to move computation
forward. (Similar to a Javascript event loop tick.)
\item \code{then()} promise domain capture: When \code{then()} is called, it will capture
the current promise domain. This promise domain is restored (only if
needed) when evaluating the given \code{onFulfilled} and \code{onRejected} callbacks.
This captured promise domain does not go into any downstream promise chain
objects. The only way the promise domain is captured is exactly when the
\code{then()} method is called.
}

\code{with_ospan_promise_domain()} creates a promise domain that restores the
currently active OpenTelemetry span from when a call to \code{promises::then()} is
executed. Given the special circumstance where only the current ospan is
needed to continue recording (not a full ancestry tree of ospans), we can
capture \emph{just} the current ospan and reactivate that ospan during promise
domain restoration.
}

\subsection{Complexity}{

When reactivating the \code{k}th step in a promise chain, the currently active
ospan (during the call to \code{then()}) will be reactivated during promise domain
restoration (\code{O(1)}). To restore a chain of promises, the active ospan will
be restored at each step (\code{O(n)}) due to the \strong{\code{n}} calls to wrapping each
\code{onFulfilled} and \code{onRejected} callbacks inside \code{then()}.

If we did NOT have a handoff promise domain for ospan restoration, a regular
promise domain approach would be needed at each step to restore the active
ospan. Each step would call \code{with_active_span()} \code{k} times (\code{O(k)}, where as
handoff domain computes in \code{O(1)}). Taking a step back, to restore each ospan
at for every step in a promise chain would then take \code{O(n^2)} time, not
\code{O(n)}. The standard, naive promise domain approach does not scale for
multiple similar promise domain restorations.
}

\subsection{Execution model}{
\enumerate{
\item \code{with_ospan_promise_domain(expr)} is called.
\itemize{
\item The following steps all occur within \code{expr}.
}
\item Create an ospan object using \code{create_ospan()} or \code{otel::start_span()}.
\itemize{
\item We need the ospan to be active during the a followup async operation.
Therefore, \code{otel::start_local_active_span()} is not appropriate as the
ospan would be ended when the function exits, not when the promise chain
resolves.
}
\item Be sure your ospan is activated before calling \code{promises::then()}.
\itemize{
\item Activate it using \code{with_ospan_async(name, expr)} (which also
creates/ends the ospan) or \code{otel::with_active_span(span, expr)}.
}
\item Call \code{promises::then()}
}
\itemize{
\item When \code{promises::then()} is called, the two methods (\code{onFulfilled} and
\code{onRejected}) capture the currently active spans. (Performed by the
initial \code{with_ospan_promise_domain()})
}
\enumerate{
\item During reactivation of the promise chain step, the previously captured
ospan is reactivated via \code{with_active_span()}. (Performed by the initial
\code{with_ospan_promise_domain()})
}
}
}

\section{OpenTelemetry span compatibility}{


For ospan objects to exist over may async ticks, the ospan must be created
using \code{create_ospan()} (or \code{otel::start_span()}) and later ended using
\code{end_ospan()} (or \code{otel::end_span()}). Ending the ospan must occur \strong{after}
any promise chain work has completed.

If we were to instead use \code{otel::start_local_active_span()}, the ospan would
be ended when the function exits, not when the promise chain completes. Even
though the local ospan is created, activated, and eventually ended, the ospan
will not exist during reactivation of the ospan promise domain.

\code{with_ospan_async()} is a convenience method that creates, activates, and
ends the ospan only after the returned promise (if any) resolves. It also
properly handles both synchronous (ending the ospan within \code{on.exit()}) and
asynchronous operations (ending the ospan within \code{promises::finally()}).
}

\examples{
\dontrun{
# Set up promise domain to be able to restore active otel span
# * Makes a small promise domain that will restore the active span from when
#   `promises::then()` is called
# * Does not activate any spans, the author must do that themselves
#   (or use `with_ospan_async()`)
with_ospan_promise_domain({

  # ... deep inside some code execution ...

  # Synchronous operation
  # * Creates `my_operation` span
  result <- with_ospan_async("my_operation", {
    # ... do some work ...
    42
  })

  # Asynchronous operation
  # * Creates `async_op` ospan
  # * Automatically ends the ospan (`async_op`) when the promise (p)
  #   resolves or rejects

  # t0.0
  with_ospan_async("async_op", {
    # ... return a promise ...
    p <- # t0.1
      init_async_work() |> # t0.2
      then(some_async_work) # t1.0
  }) # t0.3
  p2 <- p |> # t0.4
    then(more_async_work) # t2.0
})
}
}
\keyword{internal}
