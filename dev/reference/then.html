<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Access the results of a promise — then • promises</title><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/Source_Sans_Pro-0.4.10/font.css" rel="stylesheet"><link href="../deps/Source_Code_Pro-0.4.10/font.css" rel="stylesheet"><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet"><link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet"><script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Access the results of a promise — then"><meta name="description" content="Use the then function to access the eventual result of a promise (or, if
the operation fails, the reason for that failure). Regardless of the state of
the promise, the call to then is non-blocking, that is, it returns
immediately; so what it does not do is immediately return the result value
of the promise. Instead, you pass logic you want to execute to then, in the
form of function callbacks. If you provide an
onFulfilled callback, it will be called upon the promise's successful
resolution, with a single argument value: the result value. If you provide
an onRejected callback, it will be called if the operation fails, with a
single argument reason: the error that caused the failure."><meta property="og:description" content="Use the then function to access the eventual result of a promise (or, if
the operation fails, the reason for that failure). Regardless of the state of
the promise, the call to then is non-blocking, that is, it returns
immediately; so what it does not do is immediately return the result value
of the promise. Instead, you pass logic you want to execute to then, in the
form of function callbacks. If you provide an
onFulfilled callback, it will be called upon the promise's successful
resolution, with a single argument value: the result value. If you provide
an onRejected callback, it will be called if the operation fails, with a
single argument reason: the error that caused the failure."><meta name="robots" content="noindex"></head><body>
    <a href="#container" class="visually-hidden-focusable">Skip to content</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-none" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">promises</a>

    <small class="nav-text text-danger me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="In-development version">1.3.3.9007</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="active nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles"><li><h6 class="dropdown-header" data-toc-skip>Overview</h6></li>
    <li><a class="dropdown-item" href="../articles/promises_01_motivation.html">1. Why use promises?</a></li>
    <li><a class="dropdown-item" href="../articles/promises_02_intro.html">2. An informal intro to async programming</a></li>
    <li><a class="dropdown-item" href="../articles/promises_03_overview.html">3. Working with promises</a></li>
    <li><hr class="dropdown-divider"></li>
    <li><h6 class="dropdown-header" data-toc-skip>Integration</h6></li>
    <li><a class="dropdown-item" href="../articles/promises_04_mirai.html">4. Launching tasks with mirai</a></li>
    <li><a class="dropdown-item" href="../articles/promises_05a_futures.html">5a. Launching tasks with future</a></li>
    <li><a class="dropdown-item" href="../articles/promises_05b_future_promise.html">5b. Advanced future and promises usage</a></li>
    <li><hr class="dropdown-divider"></li>
    <li><h6 class="dropdown-header" data-toc-skip>Usage</h6></li>
    <li><a class="dropdown-item" href="../articles/promises_06_shiny.html">6. Using promises with Shiny</a></li>
    <li><a class="dropdown-item" href="../articles/promises_07_combining.html">7. Combining promises</a></li>
    <li><a class="dropdown-item" href="../articles/promises_08_casestudy.html">8. Case study: Converting a Shiny app to async</a></li>
  </ul></li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul><ul class="navbar-nav"><li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json"></form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/rstudio/promises/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul></div>


  </div>
</nav><div class="container template-reference-topic" id="container">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Access the results of a promise</h1>
      <small class="dont-index">Source: <a href="https://github.com/rstudio/promises/blob/main/R/then.R" class="external-link"><code>R/then.R</code></a></small>
      <div class="d-none name"><code>then.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>Use the <code>then</code> function to access the eventual result of a promise (or, if
the operation fails, the reason for that failure). Regardless of the state of
the promise, the call to <code>then</code> is non-blocking, that is, it returns
immediately; so what it does <em>not</em> do is immediately return the result value
of the promise. Instead, you pass logic you want to execute to <code>then</code>, in the
form of function callbacks. If you provide an
<code>onFulfilled</code> callback, it will be called upon the promise's successful
resolution, with a single argument <code>value</code>: the result value. If you provide
an <code>onRejected</code> callback, it will be called if the operation fails, with a
single argument <code>reason</code>: the error that caused the failure.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">then</span><span class="op">(</span><span class="va">promise</span>, onFulfilled <span class="op">=</span> <span class="cn">NULL</span>, onRejected <span class="op">=</span> <span class="cn">NULL</span>, <span class="va">...</span>, tee <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">catch</span><span class="op">(</span><span class="va">promise</span>, <span class="va">onRejected</span>, <span class="va">...</span>, tee <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">finally</span><span class="op">(</span><span class="va">promise</span>, <span class="va">onFinally</span><span class="op">)</span></span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>


<dl><dt id="arg-promise">promise<a class="anchor" aria-label="anchor" href="#arg-promise"></a></dt>
<dd><p>A promise object. The object can be in any state.</p></dd>


<dt id="arg-onfulfilled">onFulfilled<a class="anchor" aria-label="anchor" href="#arg-onfulfilled"></a></dt>
<dd><p>A function that will be invoked if the promise value
successfully resolves. When invoked, the function will be called with a
single argument: the resolved value. Optionally, the function can take a
second parameter <code>.visible</code> if you care whether the promise was resolved
with a visible or invisible value. The function can return a value or a
promise object, or can throw an error; these will affect the resolution of
the promise object that is returned by <code>then()</code>.</p></dd>


<dt id="arg-onrejected">onRejected<a class="anchor" aria-label="anchor" href="#arg-onrejected"></a></dt>
<dd><p>A function taking the argument <code>error</code>. The function can
return a value or a promise object, or can throw an error. If <code>onRejected</code>
is provided and doesn't throw an error (or return a promise that fails)
then this is the async equivalent of catching an error.</p></dd>


<dt id="arg--">...<a class="anchor" aria-label="anchor" href="#arg--"></a></dt>
<dd><p>Ignored.</p></dd>


<dt id="arg-tee">tee<a class="anchor" aria-label="anchor" href="#arg-tee"></a></dt>
<dd><p>If <code>TRUE</code>, ignore the return value of the callback, and use the
original value instead. This is useful for performing operations with
side-effects, particularly logging to the console or a file. If the
callback itself throws an error, and <code>tee</code> is <code>TRUE</code>, that error will still
be used to fulfill the the returned promise (in other words, <code>tee</code> only has
an effect if the callback does not throw).</p></dd>


<dt id="arg-onfinally">onFinally<a class="anchor" aria-label="anchor" href="#arg-onfinally"></a></dt>
<dd><p>A function with no arguments, to be called when the async
operation either succeeds or fails. Usually used for freeing resources that
were used during async operations.</p></dd>

</dl></div>
    <div class="section level2">
    <h2 id="formulas">Formulas<a class="anchor" aria-label="anchor" href="#formulas"></a></h2>



<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded" class="external-link"><img src="figures/lifecycle-superseded.svg" alt="[Superseded]"></a></p>
<p>With <code>{promises}</code> depending on R &gt;= 4.1, the shorthand of a formula, <code>~ fn(.)</code> is no longer recommended by the <code>{promises}</code> package or tidyverse (for
example,
<a href="https://github.com/tidyverse/purrr/commit/670c3ed9920f15da0d4175068ecddc41f0f1f335#diff-c4dcc43795da5c7f6bf5a94d957b5507ce795fedd6d3eb092ccad03678c4f76dR15" class="external-link"><code>{purrr}</code></a>)
as we now have access to the function shorthand, <code>\(x) fn(x)</code>. Please update
your code to use the new function shorthand syntax <code>\(x) fn(x, arg1, args2)</code>
instead of <code>~ fn(., arg1, arg2)</code>. The <code>.</code> can be confusing when chained with
other methods.</p>
    </div>
    <div class="section level2">
    <h2 id="chaining-promises">Chaining promises<a class="anchor" aria-label="anchor" href="#chaining-promises"></a></h2>



<p>The first parameter of <code>then</code> is a promise; given the stated purpose of the
function, this should be no surprise. However, what may be surprising is that
the return value of <code>then</code> is also a (newly created) promise. This new
promise waits for the original promise to be fulfilled or rejected, and for
<code>onFulfilled</code> or <code>onRejected</code> to be called. The result of (or error raised
by) calling <code>onFulfilled</code>/<code>onRejected</code> will be used to fulfill (reject) the
new promise.</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="va">promise_a</span> <span class="op">&lt;-</span> <span class="fu">get_data_frame_async</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">promise_b</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/then.html">then</a></span><span class="op">(</span><span class="va">promise_a</span>, onFulfilled <span class="op">=</span> <span class="va">head</span><span class="op">)</span></span></code></pre><p></p></div>
<p>In this example, assuming <code>get_data_frame_async</code> returns a promise that
eventually resolves to a data frame, <code>promise_b</code> will eventually resolve to
the first 10 or fewer rows of that data frame.</p>
<p>Note that the new promise is considered fulfilled or rejected based on
whether <code>onFulfilled</code>/<code>onRejected</code> returns a value or throws an error, not on
whether the original promise was fulfilled or rejected. In other words, it's
possible to turn failure to success and success to failure. Consider this
example, where we expect <code>some_async_operation</code> to fail, and want to consider
it an error if it doesn't:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="va">promise_c</span> <span class="op">&lt;-</span> <span class="fu">some_async_operation</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">promise_d</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/then.html">then</a></span><span class="op">(</span><span class="va">promise_c</span>,</span>
<span>  onFulfilled <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">value</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="kw"><a href="https://rdrr.io/r/base/stop.html" class="external-link">stop</a></span><span class="op">(</span><span class="st">"That's strange, the operation didn't fail!"</span><span class="op">)</span></span>
<span>  <span class="op">}</span>,</span>
<span>  onRejected <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">reason</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="co"># Great, the operation failed as expected</span></span>
<span>    <span class="cn">NULL</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">)</span></span></code></pre><p></p></div>
<p>Now, <code>promise_d</code> will be rejected if <code>promise_c</code> is fulfilled, and vice
versa.</p>
<p><strong>Warning:</strong> Be very careful not to accidentally turn failure into success,
if your error handling code is not the last item in a chain!</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="fu">some_async_operation</span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/then.html">catch</a></span><span class="op">(</span><span class="kw">function</span><span class="op">(</span><span class="va">reason</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="kw"><a href="https://rdrr.io/r/base/warning.html" class="external-link">warning</a></span><span class="op">(</span><span class="st">"An error occurred: "</span>, <span class="va">reason</span><span class="op">)</span></span>
<span>  <span class="op">}</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/then.html">then</a></span><span class="op">(</span><span class="kw">function</span><span class="op">(</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/message.html" class="external-link">message</a></span><span class="op">(</span><span class="st">"I guess we succeeded...?"</span><span class="op">)</span>  <span class="co"># No!</span></span>
<span>  <span class="op">}</span><span class="op">)</span></span></code></pre><p></p></div>
<p>In this example, the <code>catch</code> callback does not itself throw an error, so the
subsequent <code>then</code> call will consider its promise fulfilled!</p>
    </div>
    <div class="section level2">
    <h2 id="convenience-functions">Convenience functions<a class="anchor" aria-label="anchor" href="#convenience-functions"></a></h2>



<p>For readability and convenience, we provide <code>catch</code> and <code>finally</code> functions.</p>
<p>The <code>catch</code> function is equivalent to <code>then</code>, but without the <code>onFulfilled</code>
argument. It is typically used at the end of a promise chain to perform error
handling/logging.</p>
<p>The <code>finally</code> function is similar to <code>then</code>, but takes a single no-argument
function that will be executed upon completion of the promise,
regardless of whether the result is success or failure. It is typically used
at the end of a promise chain to perform cleanup tasks, like closing file
handles or database connections. Unlike <code>then</code> and <code>catch</code>, the return value
of <code>finally</code> is ignored; however, if an error is thrown in <code>finally</code>, that
error will be propagated forward into the returned promise.</p>
    </div>
    <div class="section level2">
    <h2 id="visibility">Visibility<a class="anchor" aria-label="anchor" href="#visibility"></a></h2>



<p><code>onFulfilled</code> functions can optionally have a second parameter <code>visible</code>,
which will be <code>FALSE</code> if the result value is <a href="https://rdrr.io/r/base/invisible.html" class="external-link">invisible</a>.</p>
    </div>

  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside></div>


   </div>
  <footer><div class="container">
  <div class="pkgdown-footer-left">
  <p>Developed by Joe Cheng, <a href="http://schloerke.com" class="external-link">Barret Schloerke</a>, <a href="https://github.com/wch" class="external-link">Winston Chang</a>, Charlie Gao, <a href="https://www.posit.co" class="external-link"><img src="https://www.tidyverse.org/posit-logo.svg" alt="Posit" height="16" width="62" style="margin-bottom: 3px;"></a>.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

  </div></footer></body></html>

