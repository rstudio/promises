<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Access the results of a promise — then • promises</title>


<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<!-- Bootstrap -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/cosmo/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous" />


<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script>

<!-- bootstrap-toc -->
<link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script>

<!-- Font Awesome icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous" />

<!-- clipboard.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script>

<!-- headroom.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script>

<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script>


<!-- docsearch -->
<script src="../docsearch.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/docsearch.js/2.6.3/docsearch.min.css" integrity="sha256-QOSRU/ra9ActyXkIBbiIB144aDBdtvXBcNc3OTNuX/Q=" crossorigin="anonymous" />
<link href="../docsearch.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script>



<meta property="og:title" content="Access the results of a promise — then" />
<meta property="og:description" content="Use the then function to access the eventual result of a promise (or, if the operation fails, the reason for that failure). Regardless of the state of the promise, the call to then is non-blocking, that is, it returns immediately; so what it does not do is immediately return the result value of the promise. Instead, you pass logic you want to execute to then, in the form of function callbacks (or formulas, see Details). If you provide an onFulfilled callback, it will be called upon the promise's successful resolution, with a single argument value: the result value. If you provide an onRejected callback, it will be called if the operation fails, with a single argument reason: the error that caused the failure." />


<meta name="robots" content="noindex">

<!-- mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->



  </head>

  <body data-spy="scroll" data-target="#toc">
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">promises</a>
        <span class="version label label-danger" data-toggle="tooltip" data-placement="bottom" title="In-development version">1.2.0.1</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../index.html">
    <span class="fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Learning
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="../articles/motivation.html">1. Why use promises?</a>
    </li>
    <li>
      <a href="../articles/intro.html">2. An informal intro to async programming</a>
    </li>
    <li>
      <a href="../articles/overview.html">3. Working with promises</a>
    </li>
    <li>
      <a href="../articles/futures.html">4. Launching tasks with future</a>
    </li>
    <li>
      <a href="../articles/future_promise.html">5. Advanced future and promises usage</a>
    </li>
    <li>
      <a href="../articles/shiny.html">6. Using promises with Shiny</a>
    </li>
    <li>
      <a href="../articles/combining.html">7. Combining promises</a>
    </li>
    <li>
      <a href="../articles/casestudy.html">8. Case study: Converting a Shiny app to async</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/rstudio/promises/">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
      
      <form class="navbar-form navbar-right hidden-xs hidden-sm" role="search">
        <div class="form-group">
          <input type="search" class="form-control" name="search-input" id="search-input" placeholder="Search..." aria-label="Search for..." autocomplete="off">
        </div>
      </form>
      
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header>

<div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Access the results of a promise</h1>
    <small class="dont-index">Source: <a href='https://github.com/rstudio/promises/blob/master/R/then.R'><code>R/then.R</code></a></small>
    <div class="hidden name"><code>then.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>Use the <code>then</code> function to access the eventual result of a promise (or, if the operation fails, the reason for that failure). Regardless of the state of the promise, the call to <code>then</code> is non-blocking, that is, it returns immediately; so what it does <em>not</em> do is immediately return the result value of the promise. Instead, you pass logic you want to execute to <code>then</code>, in the form of function callbacks (or formulas, see Details). If you provide an <code>onFulfilled</code> callback, it will be called upon the promise's successful resolution, with a single argument <code>value</code>: the result value. If you provide an <code>onRejected</code> callback, it will be called if the operation fails, with a single argument <code>reason</code>: the error that caused the failure.</p>
    </div>

    <pre class="usage"><span class='fu'>then</span><span class='op'>(</span><span class='va'>promise</span>, onFulfilled <span class='op'>=</span> <span class='cn'>NULL</span>, onRejected <span class='op'>=</span> <span class='cn'>NULL</span><span class='op'>)</span>

<span class='fu'>catch</span><span class='op'>(</span><span class='va'>promise</span>, <span class='va'>onRejected</span>, tee <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>)</span>

<span class='fu'>finally</span><span class='op'>(</span><span class='va'>promise</span>, <span class='va'>onFinally</span><span class='op'>)</span></pre>

    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a>Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>promise</th>
      <td><p>A promise object. The object can be in any state.</p></td>
    </tr>
    <tr>
      <th>onFulfilled</th>
      <td><p>A function (or a formula--see Details) that will be
invoked if the promise value successfully resolves. When invoked, the
function will be called with a single argument: the resolved value.
Optionally, the function can take a second parameter <code>.visible</code> if you care
whether the promise was resolved with a visible or invisible value. The
function can return a value or a promise object, or can throw an error;
these will affect the resolution of the promise object that is returned
by <code>then()</code>.</p></td>
    </tr>
    <tr>
      <th>onRejected</th>
      <td><p>A function taking the argument <code>error</code> (or a formula--see
Details). The function can return a value or a promise object, or can throw
an error. If <code>onRejected</code> is provided and doesn't throw an error (or return
a promise that fails) then this is the async equivalent of catching an
error.</p></td>
    </tr>
    <tr>
      <th>tee</th>
      <td><p>If <code>TRUE</code>, ignore the return value of the callback, and use the
original value instead. This is useful for performing operations with
side-effects, particularly logging to the console or a file. If the
callback itself throws an error, and <code>tee</code> is <code>TRUE</code>, that error will still
be used to fulfill the the returned promise (in other words, <code>tee</code> only has
an effect if the callback does not throw).</p></td>
    </tr>
    <tr>
      <th>onFinally</th>
      <td><p>A function with no arguments, to be called when the async
operation either succeeds or fails. Usually used for freeing resources that
were used during async operations.</p></td>
    </tr>
    </table>

    <h2 class="hasAnchor" id="formulas"><a class="anchor" href="#formulas"></a>Formulas</h2>

    


<p>For convenience, the <code>then()</code>, <code>catch()</code>, and <code>finally()</code> functions use
<code><a href='https://rlang.r-lib.org/reference/as_function.html'>rlang::as_function()</a></code> to convert <code>onFulfilled</code>, <code>onRejected</code>, and
<code>onFinally</code> arguments to functions. This means that you can use formulas to
create very compact anonymous functions, using <code>.</code> to access the value (in
the case of <code>onFulfilled</code>) or error (in the case of <code>onRejected</code>).</p>
    <h2 class="hasAnchor" id="chaining-promises"><a class="anchor" href="#chaining-promises"></a>Chaining promises</h2>

    


<p>The first parameter of <code>then</code> is a promise; given the stated purpose of the
function, this should be no surprise. However, what may be surprising is that
the return value of <code>then</code> is also a (newly created) promise. This new
promise waits for the original promise to be fulfilled or rejected, and for
<code>onFulfilled</code> or <code>onRejected</code> to be called. The result of (or error raised
by) calling <code>onFulfilled</code>/<code>onRejected</code> will be used to fulfill (reject) the
new promise.</p><pre><span class='va'>promise_a</span> <span class='op'>&lt;-</span> <span class='fu'>get_data_frame_async</span><span class='op'>(</span><span class='op'>)</span>
<span class='va'>promise_b</span> <span class='op'>&lt;-</span> <span class='fu'>then</span><span class='op'>(</span><span class='va'>promise_a</span>, onFulfilled <span class='op'>=</span> <span class='va'>head</span><span class='op'>)</span>
</pre>

<p>In this example, assuming <code>get_data_frame_async</code> returns a promise that
eventually resolves to a data frame, <code>promise_b</code> will eventually resolve to
the first 10 or fewer rows of that data frame.</p>
<p>Note that the new promise is considered fulfilled or rejected based on
whether <code>onFulfilled</code>/<code>onRejected</code> returns a value or throws an error, not on
whether the original promise was fulfilled or rejected. In other words, it's
possible to turn failure to success and success to failure. Consider this
example, where we expect <code>some_async_operation</code> to fail, and want to consider
it an error if it doesn't:</p><pre><span class='va'>promise_c</span> <span class='op'>&lt;-</span> <span class='fu'>some_async_operation</span><span class='op'>(</span><span class='op'>)</span>
<span class='va'>promise_d</span> <span class='op'>&lt;-</span> <span class='fu'>then</span><span class='op'>(</span><span class='va'>promise_c</span>,
  onFulfilled <span class='op'>=</span> <span class='kw'>function</span><span class='op'>(</span><span class='va'>value</span><span class='op'>)</span> <span class='op'>{</span>
    <span class='kw'><a href='https://rdrr.io/r/base/stop.html'>stop</a></span><span class='op'>(</span><span class='st'>"That's strange, the operation didn't fail!"</span><span class='op'>)</span>
  <span class='op'>}</span>,
  onRejected <span class='op'>=</span> <span class='kw'>function</span><span class='op'>(</span><span class='va'>reason</span><span class='op'>)</span> <span class='op'>{</span>
    <span class='co'># Great, the operation failed as expected</span>
    <span class='cn'>NULL</span>
  <span class='op'>}</span>
<span class='op'>)</span>
</pre>

<p>Now, <code>promise_d</code> will be rejected if <code>promise_c</code> is fulfilled, and vice
versa.</p>
<p><strong>Warning:</strong> Be very careful not to accidentally turn failure into success,
if your error handling code is not the last item in a chain!</p><pre><span class='fu'>some_async_operation</span><span class='op'>(</span><span class='op'>)</span> <span class='op'>%&gt;%</span>
  <span class='fu'>catch</span><span class='op'>(</span><span class='kw'>function</span><span class='op'>(</span><span class='va'>reason</span><span class='op'>)</span> <span class='op'>{</span>
    <span class='kw'><a href='https://rdrr.io/r/base/warning.html'>warning</a></span><span class='op'>(</span><span class='st'>"An error occurred: "</span>, <span class='va'>reason</span><span class='op'>)</span>
  <span class='op'>}</span><span class='op'>)</span> <span class='op'>%&gt;%</span>
  <span class='fu'>then</span><span class='op'>(</span><span class='kw'>function</span><span class='op'>(</span><span class='op'>)</span> <span class='op'>{</span>
    <span class='fu'><a href='https://rdrr.io/r/base/message.html'>message</a></span><span class='op'>(</span><span class='st'>"I guess we succeeded...?"</span><span class='op'>)</span>  <span class='co'># No!</span>
  <span class='op'>}</span><span class='op'>)</span>
</pre>

<p>In this example, the <code>catch</code> callback does not itself throw an error, so the
subsequent <code>then</code> call will consider its promise fulfilled!</p>
    <h2 class="hasAnchor" id="convenience-functions"><a class="anchor" href="#convenience-functions"></a>Convenience functions</h2>

    


<p>For readability and convenience, we provide <code>catch</code> and <code>finally</code> functions.</p>
<p>The <code>catch</code> function is equivalent to <code>then</code>, but without the <code>onFulfilled</code>
argument. It is typically used at the end of a promise chain to perform error
handling/logging.</p>
<p>The <code>finally</code> function is similar to <code>then</code>, but takes a single no-argument
function (or formula) that will be executed upon completion of the promise,
regardless of whether the result is success or failure. It is typically used
at the end of a promise chain to perform cleanup tasks, like closing file
handles or database connections. Unlike <code>then</code> and <code>catch</code>, the return value
of <code>finally</code> is ignored; however, if an error is thrown in <code>finally</code>, that
error will be propagated forward into the returned promise.</p>
    <h2 class="hasAnchor" id="visibility"><a class="anchor" href="#visibility"></a>Visibility</h2>

    


<p><code>onFulfilled</code> functions can optionally have a second parameter <code>visible</code>,
which will be <code>FALSE</code> if the result value is <a href='https://rdrr.io/r/base/invisible.html'>invisible</a>.</p>

  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top">
      <h2 data-toc-skip>Contents</h2>
    </nav>
  </div>
</div>


      <footer>
      <div class="copyright">
  <p>Developed by Joe Cheng, <a href='https://www.rstudio.com'><img src='https://www.tidyverse.org/rstudio-logo.svg' alt='RStudio' height='24' /></a>.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.</p>
</div>

      </footer>
   </div>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/docsearch.js/2.6.1/docsearch.min.js" integrity="sha256-GKvGqXDznoRYHCwKXGnuchvKSwmx9SRMrZOTh2g4Sb0=" crossorigin="anonymous"></script>
<script>
  docsearch({
    
    
    apiKey: 'e02966c036b2b44dfdb6dede68b3b31b',
    indexName: 'rstudio',
    inputSelector: 'input#search-input.form-control',
    transformData: function(hits) {
      return hits.map(function (hit) {
        hit.url = updateHitURL(hit);
        return hit;
      });
    }
  });
</script>



  </body>
</html>


