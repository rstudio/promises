<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>An informal introduction to async programming • promises</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/Source_Sans_Pro-0.4.10/font.css" rel="stylesheet">
<link href="../deps/Source_Code_Pro-0.4.10/font.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="An informal introduction to async programming">
<meta name="robots" content="noindex">
</head>
<body>
    <a href="#container" class="visually-hidden-focusable">Skip to content</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-none" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">promises</a>

    <small class="nav-text text-danger me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="In-development version">1.3.2.9000</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-learning" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Learning</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-learning">
<li><a class="dropdown-item" href="../articles/promises_01_motivation.html">1. Why use promises?</a></li>
    <li><a class="dropdown-item" href="../articles/promises_02_intro.html">2. An informal intro to async programming</a></li>
    <li><a class="dropdown-item" href="../articles/promises_03_overview.html">3. Working with promises</a></li>
    <li><a class="dropdown-item" href="../articles/promises_04_futures.html">4. Launching tasks with future</a></li>
    <li><a class="dropdown-item" href="../articles/promises_05_future_promise.html">5. Advanced future and promises usage</a></li>
    <li><a class="dropdown-item" href="../articles/promises_06_shiny.html">6. Using promises with Shiny</a></li>
    <li><a class="dropdown-item" href="../articles/promises_07_combining.html">7. Combining promises</a></li>
    <li><a class="dropdown-item" href="../articles/promises_08_casestudy.html">8. Case study: Converting a Shiny app to async</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/rstudio/promises/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article" id="container">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>An informal introduction to async programming</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/rstudio/promises/blob/rc-v1.3.3/vignettes/promises_02_intro.Rmd" class="external-link"><code>vignettes/promises_02_intro.Rmd</code></a></small>
      <div class="d-none name"><code>promises_02_intro.Rmd</code></div>
    </div>

    
    
<p>Hello, R and/or Shiny user! Let’s talk about async programming!</p>
<p><strong>Async programming? Sounds complicated.</strong></p>
<p>It is, very! You may want to grab some coffee.</p>
<p><strong>Ugh. Tell me why I even need to know this?</strong></p>
<p>Async programming is a major new addition to Shiny that can make
certain classes of apps dramatically more responsive under load.</p>
<p>Because R is single threaded (i.e. it can only do one thing at a
time), a given Shiny app process can also only do one thing at a time:
if it is fitting a linear model for one client, it can’t simultaneously
serve up a CSV download for another client.</p>
<p>For many Shiny apps, this isn’t a big problem; if no one processing
step takes very long, then no client has to wait an undue amount of time
before they start seeing results. But for apps that perform long-running
operations — either expensive computations that take a while to
complete, or waiting on slow network operations like database or web API
queries — your users’ experience can suffer dramatically as traffic
ramps up. Operations that normally are lightning quick, like downloading
a small JavaScript file, can get stuck in traffic behind something
slow.</p>
<p><strong>Oh, OK—more responsiveness is always good. But you said
this’ll only help for certain classes of Shiny apps?</strong></p>
<p>It’s mostly helpful for apps that have a few specific operations that
take a long time, rather than lots of little operations that are all a
bit slow on their own and add up to one big slow mess. We’re looking for
watermelons, not blueberries.</p>
<p><strong>Watermelons… sure. So then, how does this all
work?</strong></p>
<p>It all starts with <em>async functions</em>. An async function is one
that performs an operation that takes a long time, yet returns control
to you immediately. Whereas a normal function like <code>read.csv</code>
will not return until its work is done and it has the value you
requested, an asynchronous <code>read.csv.async</code> function would
kick off the CSV reading operation, but then return immediately, long
before the real work has actually completed.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://future.futureverse.org" class="external-link">future</a></span><span class="op">)</span></span>
<span><span class="fu"><a href="https://future.futureverse.org/reference/plan.html" class="external-link">plan</a></span><span class="op">(</span><span class="va">multisession</span><span class="op">)</span></span>
<span></span>
<span><span class="va">read.csv.async</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">file</span>, <span class="va">header</span> <span class="op">=</span> <span class="cn">TRUE</span>, <span class="va">stringsAsFactors</span> <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="../reference/future_promise.html">future_promise</a></span><span class="op">(</span><span class="op">{</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/utils/read.table.html" class="external-link">read.csv</a></span><span class="op">(</span><span class="va">file</span>, header <span class="op">=</span> <span class="va">header</span>, stringsAsFactors <span class="op">=</span> <span class="va">stringsAsFactors</span><span class="op">)</span></span>
<span>  <span class="op">}</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>(Don’t worry about what this definition means for now. You’ll learn
more about defining async functions in <a href="promises_04_futures.html">Launching tasks</a> and <a href="promises_05_future_promise.html">Advanced <code>future</code> and
<code>promises</code> usage</a>.)</p>
<p><strong>So instead of “read this CSV file” it’s more like “begin
reading this CSV file”?</strong></p>
<p>Yes! That’s what async functions do: they start things, and give you
back a special object called a <em>promise</em>. If it doesn’t return a
promise, it’s not an async function.</p>
<p><strong>Oh, I’ve heard of promises in R! From <a href="http://adv-r.had.co.nz/Computing-on-the-language.html" class="external-link">the NSE
chapter</a> in Hadley’s Advanced R book!</strong></p>
<p>Ah… this is awkward, but no. I’m using the word “promise”, but I’m
not referring to <em>that</em> kind of promise. For the purposes of
async programming, try to forget that you’ve ever heard of that kind of
promise, OK?</p>
<p>I know it seems needlessly confusing, but the promises we’re talking
about here are <del>shamelessly copied from</del> directly inspired by a
central abstraction in modern JavaScript, and the JS folks named them
“promises”.</p>
<p><strong>Fine, whatever. So what are these promises?</strong></p>
<p>Conceptually, they’re a stand-in for the <em>eventual result</em> of
the operation. For example, in the case of our
<code>read.csv.async</code> function, the promise is a stand-in for a
data frame. At some point, the operation is going to finish, and a data
frame is going to become available. The promise gives us a way to get at
that value.</p>
<p><strong>Let me guess: it’s an object that has
<code>has_completed()</code> and <code>get_value()</code>
methods?</strong></p>
<p>Good guess, but no. Promises are <em>not</em> a way to directly
inquire about the status of an operation, nor to directly retrieve the
result value. That is probably the simplest and most obvious way to
build an async framework, but in practice it’s very difficult to build
deeply async programs with an API like that.</p>
<p>Instead, a promise lets you <em>chain together operations</em> that
should be performed whenever the operation completes. These operations
might have side effects (like plotting, or writing to disk, or printing
to the console) or they might transform the result values somehow.</p>
<p><strong>Chain together operations? Using the <code>%&gt;%</code>
operator?</strong></p>
<p>A lot like that! You can’t use the <code>%&gt;%</code> operator
itself, but we provide a promise-compatible version of it:
<code>%...&gt;%</code>. So whereas you might do this to a regular data
frame:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://dplyr.tidyverse.org" class="external-link">dplyr</a></span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/read.table.html" class="external-link">read.csv</a></span><span class="op">(</span><span class="st">"https://rstudio.github.io/promises/data.csv"</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html" class="external-link">%&gt;%</a></span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/stats/filter.html" class="external-link">filter</a></span><span class="op">(</span><span class="va">state</span> <span class="op">==</span> <span class="st">"NY"</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html" class="external-link">%&gt;%</a></span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/utils/View.html" class="external-link">View</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<p>The async version would look like:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://dplyr.tidyverse.org" class="external-link">dplyr</a></span><span class="op">)</span></span>
<span><span class="fu">read.csv.async</span><span class="op">(</span><span class="st">"https://rstudio.github.io/promises/data.csv"</span><span class="op">)</span> <span class="op"><a href="../reference/pipes.html">%...&gt;%</a></span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/stats/filter.html" class="external-link">filter</a></span><span class="op">(</span><span class="va">state</span> <span class="op">==</span> <span class="st">"NY"</span><span class="op">)</span> <span class="op"><a href="../reference/pipes.html">%...&gt;%</a></span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/utils/View.html" class="external-link">View</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<p>The <code>%...&gt;%</code> operator here is the secret sauce. It’s
called the <em>promise pipe</em>; the <code>...</code> stands for
promise, and <code>&gt;</code> mimics the standard pipe operator.</p>
<p><strong>What a strange looking operator. Does it work just like a
regular pipe?</strong></p>
<p>In many ways <code>%...&gt;%</code> does work like a regular pipe: it
rewrites each stage’s function call to take the previous stage’s output
as the first argument. (All the <a href="https://CRAN.R-project.org/package=magrittr/vignettes/magrittr.html" class="external-link">standard
magrittr tricks</a> apply here: <code>.</code>, <code>{</code>,
parenthesized lambdas, etc.) But the differences, while subtle, are
profound.</p>
<p>The first and most important difference is that
<code>%...&gt;%</code> <em>must</em> take a promise as input; that is,
the left-hand side of the operator must be an expression that yields a
promise. The <code>%...&gt;%</code> will do the work of “extracting” the
result value from the promise, and passing that (unwrapped) result to
the function call on the right-hand side.</p>
<p>This last fact—that <code>%...&gt;%</code> passes an unwrapped, plain
old, not-a-promise value to the right-hand side—is critically important.
It means we can use promise objects with non-promise-aware functions,
with <code>%...&gt;%</code> serving as the bridge between asynchronous
and synchronous code.</p>
<p><strong>So the left-hand side of <code>%...&gt;%</code> needs to be
one of these special promise objects, but the right-hand side can be
regular R base functions?</strong></p>
<p>Yes! R base functions, dplyr, ggplot2, or whatever.</p>
<p>However, that work often can’t be done in the present, since the
whole point of a promise is that it represents work that hasn’t
completed yet. So <code>%...&gt;%</code> does the work of extracting and
piping not at the time that it’s called, but rather, sometime in the
future.</p>
<p><strong>You lost me.</strong></p>
<p>OK, let’s slow down and take this step by step. We’ll generate a
promise by calling an async function:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">df_promise</span> <span class="op">&lt;-</span> <span class="fu">read.csv.async</span><span class="op">(</span><span class="st">"https://rstudio.github.io/promises/data.csv"</span><span class="op">)</span></span></code></pre></div>
<p>Even if <code>data.csv</code> is many gigabytes,
<code>read.csv.async</code> returns immediately with a new promise. We
store it as <code>df_promise</code>. Eventually, when the CSV reading
operation successfully completes, the promise will contain a data frame,
but for now it’s just an empty placeholder.</p>
<p>One thing we definitely <em>can’t</em> do is treat
<code>df_promise</code> as if it’s simply a data frame:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Doesn't work!</span></span>
<span><span class="fu">dplyr</span><span class="fu">::</span><span class="fu">filter</span><span class="op">(</span><span class="va">df_promise</span>, <span class="va">state</span> <span class="op">==</span> <span class="st">"NY"</span><span class="op">)</span></span></code></pre></div>
<p>Try this and you’ll get an error like
<code>no applicable method for 'filter_' applied to an object of class "promise"</code>.
And the pipe won’t help you either;
<code>df_promise %&gt;% filter(state == "NY")</code> will give you the
same error.</p>
<p><strong>Right, that makes sense. <code>filter</code> is designed to
work on data frames, and <code>df_promise</code> isn’t a data
frame.</strong></p>
<p>Exactly. Now let’s try something that actually works:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">df_promise</span> <span class="op"><a href="../reference/pipes.html">%...&gt;%</a></span> <span class="fu"><a href="https://rdrr.io/r/stats/filter.html" class="external-link">filter</a></span><span class="op">(</span><span class="va">state</span> <span class="op">==</span> <span class="st">"NY"</span><span class="op">)</span></span></code></pre></div>
<p>At the moment it’s called, this code won’t appear to do much of
anything, really. But whenever the <code>df_promise</code> operation
actually completes successfully, then the result of that operation—the
plain old data frame—will be passed to
<code>filter(., state = "NY")</code>.</p>
<p><strong>OK, so that’s good. I see what you mean about
<code>%...&gt;%</code> letting you use non-promise functions with
promises. But the whole point of using the <code>filter</code> function
is to get a data frame back. If <code>filter</code> isn’t even going to
be called until some random time in the future, how do we get its value
back?</strong></p>
<p>I’ll tell you the answer, but it’s not going to be satisfying at
first.</p>
<p>When you use a regular <code>%&gt;%</code>, the result you get back
is the return value from the right-hand side:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">df_filtered</span> <span class="op">&lt;-</span> <span class="va">df</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html" class="external-link">%&gt;%</a></span> <span class="fu"><a href="https://rdrr.io/r/stats/filter.html" class="external-link">filter</a></span><span class="op">(</span><span class="va">state</span> <span class="op">==</span> <span class="st">"NY"</span><span class="op">)</span></span></code></pre></div>
<p>When you use <code>%...&gt;%</code>, the result you get back is a
promise, whose <em>eventual</em> result will be the return value from
the right-hand side:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">df_filtered_promise</span> <span class="op">&lt;-</span> <span class="va">df_promise</span> <span class="op"><a href="../reference/pipes.html">%...&gt;%</a></span> <span class="fu"><a href="https://rdrr.io/r/stats/filter.html" class="external-link">filter</a></span><span class="op">(</span><span class="va">state</span> <span class="op">==</span> <span class="st">"NY"</span><span class="op">)</span></span></code></pre></div>
<p><strong>Wait, what? If I have a promise, I can do stuff to it using
<code>%...&gt;%</code>, but then I just end up with another promise? Why
not just have <code>%...&gt;%</code> return a regular value instead of a
promise?</strong></p>
<p>Remember, the whole point of a promise is that we don’t know its
value yet! So to write a function that uses a promise as input and
returns some non-promise value as output, you’d need to either be a time
traveler or an oracle.</p>
<p>To summarize, once you start working with a promise, any calculations
and actions that are “downstream” of that promise will need to become
promise-oriented. Generally, this means once you have a promise, you
need to use <code>%...&gt;%</code> and keep using it until your pipeline
terminates.</p>
<p><strong>I guess that makes sense. Still, if the only thing you can do
with promises is make more promises, that limits their usefulness,
doesn’t it?</strong></p>
<p>It’s a different way of thinking about things, to be sure, but it
turns out there’s not much limit in usefulness—especially in the context
of a Shiny app.</p>
<p>First, you can use promises with Shiny outputs. If you’re using an
async-compatible version of Shiny (version &gt;=1.1), all of the
built-in <code>renderXXX</code> functions can deal with either regular
values or promises. An example of the latter:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">output</span><span class="op">$</span><span class="va">table</span> <span class="op">&lt;-</span> <span class="fu">renderTable</span><span class="op">(</span><span class="op">{</span></span>
<span>  <span class="fu">read.csv.async</span><span class="op">(</span><span class="st">"https://rstudio.github.io/promises/data.csv"</span><span class="op">)</span> <span class="op"><a href="../reference/pipes.html">%...&gt;%</a></span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/stats/filter.html" class="external-link">filter</a></span><span class="op">(</span><span class="va">state</span> <span class="op">==</span> <span class="st">"NY"</span><span class="op">)</span></span>
<span><span class="op">}</span><span class="op">)</span></span></code></pre></div>
<p>When <code>output$table</code> executes the <code>renderTable</code>
code block, it will notice that the result is a promise, and wait for it
to complete before continuing with the table rendering. While it’s
waiting, the R process can move on to do other things.</p>
<p>Second, you can use promises with reactive expressions. Reactive
expressions treat promises about the same as they treat other values,
actually. But this works perfectly fine:</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># A reactive expression that returns a promise</span></span>
<span><span class="va">filtered_df</span> <span class="op">&lt;-</span> <span class="fu">reactive</span><span class="op">(</span><span class="op">{</span></span>
<span>  <span class="fu">read.csv.async</span><span class="op">(</span><span class="st">"https://rstudio.github.io/promises/data.csv"</span><span class="op">)</span> <span class="op"><a href="../reference/pipes.html">%...&gt;%</a></span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/stats/filter.html" class="external-link">filter</a></span><span class="op">(</span><span class="va">state</span> <span class="op">==</span> <span class="st">"NY"</span><span class="op">)</span> <span class="op"><a href="../reference/pipes.html">%...&gt;%</a></span></span>
<span>    <span class="fu">arrange</span><span class="op">(</span><span class="va">median_income</span><span class="op">)</span></span>
<span><span class="op">}</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># A reactive expression that reads the previous</span></span>
<span><span class="co"># (promise-returning) reactive, and returns a</span></span>
<span><span class="co"># new promise</span></span>
<span><span class="va">top_n_by_income</span> <span class="op">&lt;-</span> <span class="fu">reactive</span><span class="op">(</span><span class="op">{</span></span>
<span>  <span class="fu">filtered_df</span><span class="op">(</span><span class="op">)</span> <span class="op"><a href="../reference/pipes.html">%...&gt;%</a></span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">input</span><span class="op">$</span><span class="va">n</span><span class="op">)</span></span>
<span><span class="op">}</span><span class="op">)</span></span>
<span></span>
<span><span class="va">output</span><span class="op">$</span><span class="va">table</span> <span class="op">&lt;-</span> <span class="fu">renderTable</span><span class="op">(</span><span class="op">{</span></span>
<span>  <span class="fu">top_n_by_income</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="op">}</span><span class="op">)</span></span></code></pre></div>
<p>Third, you can use promises in reactive observers. Use them to
perform asynchronous tasks in response to reactivity.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">observeEvent</span><span class="op">(</span><span class="va">input</span><span class="op">$</span><span class="va">save</span>, <span class="op">{</span></span>
<span>  <span class="fu">filtered_df</span><span class="op">(</span><span class="op">)</span> <span class="op"><a href="../reference/pipes.html">%...&gt;%</a></span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/utils/write.table.html" class="external-link">write.csv</a></span><span class="op">(</span><span class="st">"ny_data.csv"</span><span class="op">)</span></span>
<span><span class="op">}</span><span class="op">)</span></span></code></pre></div>
<p><strong>Alright, I think I see what you mean. You can’t escape from
promise-land, but there’s no need to, because Shiny knows what to do
with them.</strong></p>
<p>Yes, that’s basically right. You just need to keep track of which
functions and reactive expressions return promises instead of regular
values, and be sure to interact with them using <code>%...&gt;%</code>
or other promise-aware operators and functions.</p>
<p><strong>Wait, there are other promise-aware operators and
functions?</strong></p>
<p>Yes. The <code>%...&gt;%</code> is the one you’ll most commonly use,
but there is a variant <code>%...T&gt;%</code>, which we call the
<em>promise tee</em> operator (it’s analogous to the magrittr
<code>%T&gt;%</code> operator). The <code>%...T&gt;%</code> operator
mostly acts like <code>%...&gt;%</code>, but instead of returning a
promise for the result value, it returns the original value instead.
Meaning <code>p %...T&gt;% cat("\n")</code> won’t return a promise for
the return value of <code><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat()</a></code> (which is always
<code>NULL</code>) but instead the value of <code>p</code>. This is
useful for logging, or other “side effecty” operations.</p>
<p>There’s also <code>%...!%</code>, and its tee version,
<code>%...T!%</code>, which are used for error handling. I won’t confuse
you with more about that now, but you can read more <a href="promises_03_overview.html#error-handling">here</a>.</p>
<p>The <code>promises</code> package is where all of these operators
live, and it also comes with some additional functions for working with
promises.</p>
<p>So far, the only actual async function we’ve talked about has been
<code>read.csv.async</code>, which doesn’t actually exist. To learn
where actual async functions come from, read <a href="promises_04_futures.html">this guide to the <code>future</code>
package</a>.</p>
<p>There are the lower-level functions <code>then</code>,
<code>catch</code>, and <code>finally</code>, which are the non-pipe,
non-operator equivalents of the promise operators we’ve been discussing.
See <a href="promises_03_overview.html#accessing-results-with-then">reference</a>.</p>
<p>And finally, there are <code>promise_all</code>,
<code>promise_race</code>, and <code>promise_lapply</code>, used to
combine multiple promises into a single promise. Learn more about them
<a href="../reference/promise_all.html">here</a>.</p>
<p><strong>OK, looks like I have a lot of stuff to read up on. And I’ll
probably have to reread this conversation a few times before it fully
sinks in.</strong></p>
<p>Sorry. I told you it was complicated. If you make it through the rest
of the guide, you’ll be 95% of the way there.</p>
<div style="font-size: 20px; margin-top: 40px; text-align: right;">
<p>Next: <a href="promises_03_overview.html">Working with
promises</a></p>
</div>
  </main>
</div>



   </div>
  <footer><div class="container">
  <div class="pkgdown-footer-left">
  <p>Developed by Joe Cheng, <a href="https://www.posit.co" class="external-link"><img src="https://www.tidyverse.org/posit-logo.svg" alt="Posit" height="16" width="62" style="margin-bottom: 3px;"></a>.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

  </div></footer>
</body>
</html>
