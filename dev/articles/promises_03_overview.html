<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Working with promises in R • promises</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="96x96" href="../favicon-96x96.png">
<link rel="icon" type="”image/svg+xml”" href="../favicon.svg">
<link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
<link rel="icon" sizes="any" href="../favicon.ico">
<link rel="manifest" href="../site.webmanifest">
<script src="../lightswitch.js"></script><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/Nunito-0.4.10/font.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><script src="../extra.js"></script><meta property="og:title" content="Working with promises in R">
<meta name="robots" content="noindex">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top " aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">promises</a>

    <small class="nav-text text-danger me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="In-development version">1.4.0.9000</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><h6 class="dropdown-header" data-toc-skip>Overview</h6></li>
    <li><a class="dropdown-item" href="../articles/promises_01_motivation.html">1. Why use promises?</a></li>
    <li><a class="dropdown-item" href="../articles/promises_02_intro.html">2. An informal intro to async programming</a></li>
    <li><a class="dropdown-item" href="../articles/promises_03_overview.html">3. Working with promises</a></li>
    <li><hr class="dropdown-divider"></li>
    <li><h6 class="dropdown-header" data-toc-skip>Integration</h6></li>
    <li><a class="dropdown-item" href="../articles/promises_04_mirai.html">4. Launching tasks with mirai</a></li>
    <li><a class="dropdown-item" href="../articles/promises_05a_futures.html">5a. Launching tasks with future</a></li>
    <li><a class="dropdown-item" href="../articles/promises_05b_future_promise.html">5b. Advanced future and promises usage</a></li>
    <li><hr class="dropdown-divider"></li>
    <li><h6 class="dropdown-header" data-toc-skip>Usage</h6></li>
    <li><a class="dropdown-item" href="../articles/promises_06_shiny.html">6. Using promises with Shiny</a></li>
    <li><a class="dropdown-item" href="../articles/promises_07_combining.html">7. Combining promises</a></li>
    <li><a class="dropdown-item" href="../articles/promises_08_casestudy.html">8. Case study: Converting a Shiny app to async</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/rstudio/promises/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-lightswitch" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true" aria-label="Light switch"><span class="fa fa-sun"></span></button>
  <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="dropdown-lightswitch">
<li><button class="dropdown-item" data-bs-theme-value="light"><span class="fa fa-sun"></span> Light</button></li>
    <li><button class="dropdown-item" data-bs-theme-value="dark"><span class="fa fa-moon"></span> Dark</button></li>
    <li><button class="dropdown-item" data-bs-theme-value="auto"><span class="fa fa-adjust"></span> Auto</button></li>
  </ul>
</li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.svg" class="logo" alt=""><h1>Working with promises in R</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/rstudio/promises/blob/rc-v1.5.0/vignettes/promises_03_overview.Rmd" class="external-link"><code>vignettes/promises_03_overview.Rmd</code></a></small>
      <div class="d-none name"><code>promises_03_overview.Rmd</code></div>
    </div>

    
    
<p>One persistent challenge with developing Shiny apps for live
deployment is the R language runtime’s single-threaded nature. Because
of this, a given Shiny app process can only do one thing at a time: if
it is fitting a linear model for one client, it cannot simultaneously
prepare a CSV download for another client, and vice versa.</p>
<p>For many Shiny apps, this isn’t a big problem; because no one
processing step takes very long, no client has to wait an undue amount
of time before they start seeing results. But for apps that perform
long-running operations — either expensive computations that take a
while to complete, or waiting on slow network operations like database
or web API queries — your users’ experience can suffer dramatically as
traffic ramps up.</p>
<p>The traditional approach to scaling web applications is to launch
multiple processes and balance traffic between them, and indeed, Shiny
Server Pro and RStudio Connect both implement a variant of this
strategy. You do some load testing to determine how many concurrent
users a single process can support, then <a href="https://docs.posit.co/shiny-server/" class="external-link">configure Shiny Server
Pro</a> to launch new processes as those limits are approached.</p>
<p>But there are some applications that perform truly expensive
operations, like simulations, training neural networks, or complex
per-row processing, that take <em>minutes</em> to complete. Again, while
this is happening, any other users that are unfortunate enough to be
assigned to the same process are completely blocked from proceeding in
any way — even loading static JavaScript/CSS assets must wait until the
blocking operation is complete.</p>
<p>Asynchronous (async) programming offers a way to offload certain
classes of long-running operations from the main R thread, such that
Shiny apps can remain responsive.</p>
<p>A warning before we dive in: async code is hard to write! It is hard
in C++, it is hard in Java, it is hard in JavaScript, and sadly, R is no
exception. We have attempted to make the API as simple and elegant as
possible, but just as with reactive programming, it will likely take
some effort to internalize the main concepts, and plenty of practice
before expressing logic this way begins to feel natural.</p>
<div class="section level2">
<h2 id="async-programming-in-r">Async programming in R<a class="anchor" aria-label="anchor" href="#async-programming-in-r"></a>
</h2>
<p>Integrating async programming capabilities into R involves two types
of tasks:</p>
<ol style="list-style-type: decimal">
<li>
<strong>Invoking:</strong> Getting expensive operations to happen
either on a different thread, or (more likely) in a different process,
leaving the main R thread/process free to continue doing other work.
Generally, an expensive operation will either produce a result value
(e.g. a data frame), or cause a side effect (e.g. a write to a
database).</li>
<li>
<strong>Handling:</strong> When an operation completes or fails,
notify the main R thread/process so that it may make use of the
resulting value or error in further logic. Handling logic may choose to
perform side effects like logging or persisting, or to transform the
value/error for further downstream processing.</li>
</ol>
<p>In our vision for R async programming, there should be several
different ways of invoking expensive operations asynchronously, each
with different tradeoffs, depending on the type of task you are trying
to execute. We will go into more detail later, but just to give you an
idea, here are just a few of the different strategies you could use to
invoke code asynchronously:</p>
<ul>
<li>Run it in the current process, but on a different thread. (This
strategy is impossible for R code, but you can run C/C++ code on a
different thread, even in an R process.)</li>
<li>Launch a separate R process and pass it the R code to evaluate.</li>
<li>Fork the R process and run the code in the child process. (Doesn’t
work on Windows.)</li>
<li>Farm the code out to a pre-allocated cluster of R processes, either
on the same machine or distributed across a network.</li>
</ul>
<p>Regardless of which approach you choose, the API for handling the
result is identical. It’s centered around an abstraction that you will
come to know very well: the <strong>promise</strong>.</p>
</div>
<div class="section level2">
<h2 id="promises-the-central-abstraction-of-async-programming">Promises: the central abstraction of async programming<a class="anchor" aria-label="anchor" href="#promises-the-central-abstraction-of-async-programming"></a>
</h2>
<blockquote>
<p><strong>Terminology note:</strong> Advanced R users (or users who
have at least read <a href="http://adv-r.had.co.nz/Computing-on-the-language.html" class="external-link">Advanced
R</a>) may be familiar with the term “promises” already: in R,
unevaluated function arguments are technically called promises. Those
types of promises have nothing to do with asynchronous programming, and
the things we call “promises” in this document have nothing to do with
those, so try to forget they exist for the time being. Sorry for the
confusion.</p>
</blockquote>
<p>A promise is an object that represents the <em>eventual result</em>
of a specific asynchronous operation.</p>
<p>Whenever you launch an async task, you get a promise object back.
That promise is what lets you know:</p>
<ul>
<li>When the task completes (if ever)</li>
<li>Whether the task completed successfully or failed</li>
<li>If success, the result value</li>
<li>If failure, the error</li>
</ul>
<p>So if a regular, synchronous function call generally looks like
this:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">value</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/utils/read.table.html" class="external-link">read.csv</a></span><span class="op">(</span><span class="st">"http://example.com/data/data.csv"</span><span class="op">)</span></span></code></pre></div>
<p>An asynchronous function call (which uses <a href="promises_04_mirai.html">the mirai package</a>) will look instead
like:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">promise</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/is.promise.html">as.promise</a></span><span class="op">(</span><span class="fu"><a href="https://mirai.r-lib.org/reference/mirai.html" class="external-link">mirai</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/utils/read.table.html" class="external-link">read.csv</a></span><span class="op">(</span><span class="st">"http://example.com/data/data.csv"</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>While the regular function call returns a data frame, the async call
returns a promise, which is most definitely not a data frame. You cannot
ask the promise how many rows it has, or the names of its columns. You
cannot run dplyr operations on it, or turn it into a data.table.</p>
<p>You might guess that you could call a function or method on a promise
to extract the value, like <code>value(promise)</code> or
<code>promise$value()</code>. But that isn’t how promises work. Instead,
everything is based on a function called <code>then</code>.</p>
</div>
<div class="section level2">
<h2 id="accessing-results-with-then">Accessing results with <code>then</code><a class="anchor" aria-label="anchor" href="#accessing-results-with-then"></a>
</h2>
<p>The <code><a href="../reference/then.html">promises::then</a></code> function is what ultimately makes
promise objects useful. It is used to register success and failure
handlers on a promise. Its signature looks like:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/then.html">then</a></span><span class="op">(</span><span class="va">promise</span>, onFulfilled <span class="op">=</span> <span class="cn">NULL</span>, onRejected <span class="op">=</span> <span class="cn">NULL</span>, <span class="va">...</span>, tee <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre></div>
<p>In promise terminology, “fulfilled” (and equivalently, “resolved”)
means success and “rejected” means failure. You can pass functions with
single arguments to <code>onFulfilled</code> and <code>onRejected</code>
to be notified when a promise succeeds or fails. (If the promise has
already been fulfilled or resolved by the time <code>then</code> is
called, don’t worry—the appropriate callback will be still be called.
It’s never too late to call <code>then</code> on a promise.)</p>
<p>The promise library guarantees that only one of
<code>onFulfilled</code> or <code>onRejected</code> will be called,
never both. And a callback will never be invoked more than once. It is
possible, though, that neither callback will ever be called, i.e. the
async operation never completes. (This is analogous to calling a regular
function that never returns.)</p>
<p>For now, we will focus on fulfillment, and come back to rejection in
the <a href="#error-handling">Error Handling</a> section below.</p>
<p>The following example shows a simple example of printing out a
success message and the value.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/then.html">then</a></span><span class="op">(</span><span class="va">promise</span>,</span>
<span>  \<span class="op">(</span><span class="va">value</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat</a></span><span class="op">(</span><span class="st">"The operation completed!\n"</span><span class="op">)</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">value</span><span class="op">)</span></span>
<span>  <span class="op">}</span><span class="op">)</span></span></code></pre></div>
<p>In the example above, we used the anonymous function shorthand
(<code>\(x) { }</code>) to write an anonymous function.
<code>function(x) { }</code> would behave just the same.</p>
<p>To help reduce the amount of in/out reading, we can use the R pipe
operator (<code>|&gt;</code>):</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">promise</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/then.html">then</a></span><span class="op">(</span>\<span class="op">(</span><span class="va">value</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat</a></span><span class="op">(</span><span class="st">"The operation completed!\n"</span><span class="op">)</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">value</span><span class="op">)</span></span>
<span>  <span class="op">}</span><span class="op">)</span></span></code></pre></div>
<p>Note that the call to <code><a href="../reference/then.html">then()</a></code> <strong>always returns
immediately</strong>, without invoking the callback function. The
callback function will be invoked sometime in the future—it could be
very soon, or it could be hours, depending mostly on how long it takes
the async operation to complete.</p>
</div>
<div class="section level2">
<h2 id="promise-chaining">Promise chaining<a class="anchor" aria-label="anchor" href="#promise-chaining"></a>
</h2>
<p>The <code><a href="../reference/then.html">then()</a></code> function has an important function beyond
registering callbacks. It also returns a promise—not the promise it
takes as an argument, but a new, distinct promise. This new promise gets
fulfilled after the input promise has resolved and the callback
registered by <code><a href="../reference/then.html">then()</a></code> has run; the return value of the
callback is used to fulfill the new promise.</p>
<p>For example:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">p</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/promise_resolve.html">promise_resolve</a></span><span class="op">(</span><span class="fu">palmerpenguins</span><span class="fu">::</span><span class="va">penguins</span><span class="op">)</span></span>
<span><span class="va">p2</span> <span class="op">&lt;-</span> <span class="va">p</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/then.html">then</a></span><span class="op">(</span><span class="va">nrow</span><span class="op">)</span></span></code></pre></div>
<p>In this case, after <code>p</code> is fulfilled with a data frame,
<code>p2</code> will be fulfilled with the number of rows of that data
frame.</p>
<p>Because <code><a href="../reference/then.html">then()</a></code> uses promises for both input and output,
you can chain multiple <code><a href="../reference/then.html">then()</a></code> calls together directly:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">p</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/then.html">then</a></span><span class="op">(</span>\<span class="op">(</span><span class="va">df</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/stats/filter.html" class="external-link">filter</a></span><span class="op">(</span><span class="va">df</span>, <span class="va">year</span> <span class="op">==</span> <span class="fl">2008</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/then.html">then</a></span><span class="op">(</span>\<span class="op">(</span><span class="va">df</span><span class="op">)</span> <span class="fu">group_by</span><span class="op">(</span><span class="va">df</span>, <span class="va">species</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/then.html">then</a></span><span class="op">(</span>\<span class="op">(</span><span class="va">df</span><span class="op">)</span> <span class="fu">summarise</span><span class="op">(</span><span class="va">df</span>, mean_bill <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="va">bill_length_mm</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/then.html">then</a></span><span class="op">(</span>\<span class="op">(</span><span class="va">df</span><span class="op">)</span> <span class="fu">arrange</span><span class="op">(</span><span class="va">df</span>, <span class="fu">desc</span><span class="op">(</span><span class="va">mean_bill</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/then.html">then</a></span><span class="op">(</span><span class="va">print</span><span class="op">)</span></span>
<span><span class="co">#&gt; # A tibble: 3 × 2</span></span>
<span><span class="co">#&gt;   species   mean_bill</span></span>
<span><span class="co">#&gt;   &lt;fct&gt;         &lt;dbl&gt;</span></span>
<span><span class="co">#&gt; 1 Chinstrap      48.7</span></span>
<span><span class="co">#&gt; 2 Gentoo         46.9</span></span>
<span><span class="co">#&gt; 3 Adelie         38.6</span></span></code></pre></div>
<p>Or, equivalently:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">p</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/then.html">then</a></span><span class="op">(</span>\<span class="op">(</span><span class="va">df</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="va">df</span> <span class="op">|&gt;</span></span>
<span>      <span class="fu"><a href="https://rdrr.io/r/stats/filter.html" class="external-link">filter</a></span><span class="op">(</span><span class="va">year</span> <span class="op">==</span> <span class="fl">2008</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>      <span class="fu">group_by</span><span class="op">(</span><span class="va">state</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>      <span class="fu">summarise</span><span class="op">(</span>pop <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">population</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>      <span class="fu">arrange</span><span class="op">(</span><span class="fu">desc</span><span class="op">(</span><span class="va">pop</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="op">}</span><span class="op">)</span></span></code></pre></div>
<p>Evaluating this expression results in a promise that will eventually
resolve to the filtered, summarized, and ordered data.</p>
</div>
<div class="section level2">
<h2 id="tee-operator">Tee operator<a class="anchor" aria-label="anchor" href="#tee-operator"></a>
</h2>
<p>When working with promise pipelines, it may sometimes be useful to
have a stage that performs an action but does not modify the value
presented to downstream stages. For example, you may want to log the
number of rows in a data frame for diagnostic purposes:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Incorrect!</span></span>
<span><span class="va">promise</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/then.html">then</a></span><span class="op">(</span>\<span class="op">(</span><span class="va">df</span><span class="op">)</span> <span class="va">df</span> <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/stats/filter.html" class="external-link">filter</a></span><span class="op">(</span><span class="va">year</span> <span class="op">==</span> <span class="fl">2008</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/then.html">then</a></span><span class="op">(</span>\<span class="op">(</span><span class="va">df</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">df</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/then.html">then</a></span><span class="op">(</span>\<span class="op">(</span><span class="va">df</span><span class="op">)</span> <span class="va">df</span> <span class="op">|&gt;</span> <span class="fu">group_by</span><span class="op">(</span><span class="va">state</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/then.html">then</a></span><span class="op">(</span>\<span class="op">(</span><span class="va">df</span><span class="op">)</span> <span class="va">df</span> <span class="op">|&gt;</span> <span class="fu">summarise</span><span class="op">(</span>pop <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">population</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/then.html">then</a></span><span class="op">(</span>\<span class="op">(</span><span class="va">df</span><span class="op">)</span> <span class="va">df</span> <span class="op">|&gt;</span> <span class="fu">arrange</span><span class="op">(</span><span class="fu">desc</span><span class="op">(</span><span class="va">pop</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/then.html">then</a></span><span class="op">(</span><span class="va">print</span><span class="op">)</span></span></code></pre></div>
<p>This is not correct, as the <code>print(nrow(df))</code> stage will
not only print the desired value, but pass the return value of
<code>print(nrow(.))</code>, which is just
<code>invisible(nrow(df))</code>, to the next stage.</p>
<p>For synchronous code, the <a href="https://magrittr.tidyverse.org/reference/tee.html" class="external-link"><code>{magrittr}</code>
package offered the <code>%T&gt;%</code> (pronounced “tee”)
operator</a>, which operates like a regular <code>|&gt;</code> except
that, after executing its right-hand side, it returns its left-hand side
value.</p>
<p>Similarly, for asynchronous code, you can use the
<code>then(tee = TRUE)</code> method, which is like <code><a href="../reference/then.html">then()</a></code>
except that after execution it resolves using its input promise. The
only difference in the corrected code below is the operator immediately
preceding <code>print(nrow(df))</code> has changed from
<code><a href="../reference/then.html">then()</a></code> to <code>then(tee = TRUE)</code>.</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Correct.</span></span>
<span><span class="va">promise</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/then.html">then</a></span><span class="op">(</span>\<span class="op">(</span><span class="va">df</span><span class="op">)</span> <span class="va">df</span> <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/stats/filter.html" class="external-link">filter</a></span><span class="op">(</span><span class="va">year</span> <span class="op">==</span> <span class="fl">2008</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/then.html">then</a></span><span class="op">(</span>tee <span class="op">=</span> <span class="cn">TRUE</span>, \<span class="op">(</span><span class="va">df</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">df</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/then.html">then</a></span><span class="op">(</span>\<span class="op">(</span><span class="va">df</span><span class="op">)</span> <span class="va">df</span> <span class="op">|&gt;</span> <span class="fu">group_by</span><span class="op">(</span><span class="va">state</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/then.html">then</a></span><span class="op">(</span>\<span class="op">(</span><span class="va">df</span><span class="op">)</span> <span class="va">df</span> <span class="op">|&gt;</span> <span class="fu">summarise</span><span class="op">(</span>pop <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">population</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/then.html">then</a></span><span class="op">(</span>\<span class="op">(</span><span class="va">df</span><span class="op">)</span> <span class="va">df</span> <span class="op">|&gt;</span> <span class="fu">arrange</span><span class="op">(</span><span class="fu">desc</span><span class="op">(</span><span class="va">pop</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/then.html">then</a></span><span class="op">(</span><span class="va">print</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="error-handling">Error handling<a class="anchor" aria-label="anchor" href="#error-handling"></a>
</h2>
<p>Many scripts and Shiny apps that use promises will not contain any
explicit error handling code at all, just like most scripts and Shiny
apps don’t contain <code>tryCatch</code> or <code>try</code> calls to
handle errors in synchronous code. But if you need to handle errors,
promises have a robust and flexible mechanism for doing so.</p>
<div class="section level3">
<h3 id="catching-errors-with-onrejected">Catching errors with <code>onRejected</code><a class="anchor" aria-label="anchor" href="#catching-errors-with-onrejected"></a>
</h3>
<p>The lowest level of error handling is built into the
<code>then</code> function. To review, the <code>then</code> function
takes an input promise, and up to two callbacks:
<code>onFulfilled</code> and <code>onRejected</code>; and it returns a
new promise as output. If the operation behind by the input promise
succeeds, the <code>onFulfilled</code> callback (if provided) will be
invoked. If the input promise’s operation fails, then
<code>onRejected</code> (if provided) will be invoked with an error
object.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">promise2</span> <span class="op">&lt;-</span> <span class="va">promise1</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/then.html">then</a></span><span class="op">(</span></span>
<span>    onFulfilled <span class="op">=</span> \<span class="op">(</span><span class="va">value</span><span class="op">)</span> <span class="op">{</span></span>
<span>      <span class="co"># Getting here means promise1 succeeded</span></span>
<span>    <span class="op">}</span>,</span>
<span>    onRejected <span class="op">=</span> \<span class="op">(</span><span class="va">err</span><span class="op">)</span> <span class="op">{</span></span>
<span>      <span class="co"># Getting here means promise1 failed</span></span>
<span>    <span class="op">}</span></span>
<span>  <span class="op">)</span></span></code></pre></div>
<p>In the code above, you can see that the success or failure of
<code>promise1</code> is what will determine which of the two callbacks
is invoked.</p>
<p>But what about the output promise, <code>promise2</code>? We know
what happens if <code>promise1</code> succeeds and the
<code>onFulfilled</code> callback returns normally:
<code>promise2</code> is resolved with the return value of
<code>onFulfilled</code> (and if that return value is itself a promise,
then <code>promise2</code> will do whatever that promise does). What
happens if <code>promise1</code> is rejected; does that automatically
mean <code>promise2</code> is rejected as well?</p>
<p>The answer is no, <code>promise2</code> is not automatically rejected
if <code>promise1</code> is rejected. The rejection of
<code>promise1</code> causes <code>onRejected</code> to be called, but
from there on, <code>onFulfilled</code> and <code>onRejected</code> are
treated identically. Whichever callback is invoked, if the invocation of
the callback succeeds (returns either a regular value, or, a promise
that ultimately resolves successfully) then the output promise will be
resolved/succeed. But if the invocation of the callback fails (either
throws an error, or returns a promise that ultimately rejects) then the
output promise will be rejected/fail.</p>
<p>If you think about it, this behavior makes sense; just like
<code>tryCatch</code>, once you’ve caught an error, it doesn’t continue
to propagate, unless you go out of your way to do so by re-throwing it
using <code>stop(err)</code>.</p>
<p>So the equivalent to this (synchronous) code:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">value</span> <span class="op">&lt;-</span> <span class="kw"><a href="https://rdrr.io/r/base/conditions.html" class="external-link">tryCatch</a></span><span class="op">(</span></span>
<span>  <span class="fu">somepkg</span><span class="fu">::</span><span class="fu">operation</span><span class="op">(</span><span class="op">)</span>,</span>
<span>  error <span class="op">=</span> \<span class="op">(</span><span class="va">err</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="kw"><a href="https://rdrr.io/r/base/warning.html" class="external-link">warning</a></span><span class="op">(</span><span class="st">"An error occurred: "</span>, <span class="va">err</span><span class="op">)</span></span>
<span>    <span class="kw"><a href="https://rdrr.io/r/base/warning.html" class="external-link">warning</a></span><span class="op">(</span><span class="st">"Using default value of 0 instead"</span><span class="op">)</span></span>
<span>    <span class="fl">0</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>would be this, when the operation is performed asynchronously:</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">promise</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://mirai.r-lib.org/reference/mirai.html" class="external-link">mirai</a></span><span class="op">(</span><span class="fu">somepkg</span><span class="fu">::</span><span class="fu">operation</span><span class="op">(</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/then.html">then</a></span><span class="op">(</span>onRejected <span class="op">=</span> \<span class="op">(</span><span class="va">err</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="kw"><a href="https://rdrr.io/r/base/warning.html" class="external-link">warning</a></span><span class="op">(</span><span class="st">"An error occurred: "</span>, <span class="va">err</span><span class="op">)</span></span>
<span>    <span class="kw"><a href="https://rdrr.io/r/base/warning.html" class="external-link">warning</a></span><span class="op">(</span><span class="st">"Using default value of 0 instead"</span><span class="op">)</span></span>
<span>    <span class="fl">0</span></span>
<span>  <span class="op">}</span><span class="op">)</span></span></code></pre></div>
<p>In the synchronous case, an error in <code>operation()</code> will
result in the error being logged as a warning, and <code>0</code> being
assigned to <code>value</code>. In the asynchronous case, the same
warning log messages will happen but then the value of <code>0</code>
will be used to resolve <code>promise</code>. In both cases, the error
is caught, dealt with, and turned into a non-error.</p>
</div>
<div class="section level3">
<h3 id="default-onrejected-behavior">Default onRejected behavior<a class="anchor" aria-label="anchor" href="#default-onrejected-behavior"></a>
</h3>
<p>In many of the examples above, we called <code>then</code> with an
<code>onFulfilled</code> but no <code>onRejected</code>. What is the
behavior of <code>then</code> if its input promise is rejected with an
error, but the caller has not provided an explicit
<code>onRejected</code> callback?</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">promise2</span> <span class="op">&lt;-</span> <span class="va">promise1</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/then.html">then</a></span><span class="op">(</span><span class="va">head</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/then.html">then</a></span><span class="op">(</span><span class="va">print</span><span class="op">)</span></span></code></pre></div>
<p>Well, <code>then</code> has its own default version of
<code>onRejected</code>. It’s <em>not</em> an empty
<code>onRejected = \(err) { }</code>, as you might think. Even though
this function has no code in its body, it still returns normally, and
thus would cause any errors to be caught and swallowed. That’s not the
behavior we want; in the code above, we want a failure in
<code>promise1</code> to cause <code>promise2</code> to be rejected so
we know that something went wrong. So the default callback actually
looks like: <code>onRejected = stop</code>, meaning, do nothing but
raise the error, pushing the responsibility for error handling
downstream.</p>
<p>(Incidentally, it’s valid to call <code>then</code> with
<code>onRejected</code> and not <code>onFulfilled</code>, and the
default version of <code>onFulfilled</code> is not an empty function
either; instead, it’s <code>onFulfilled = identity</code>, so that the
input promise’s return value can be passed through to the output
promise.)</p>
</div>
<div class="section level3">
<h3 id="syntactic-sugar-for-onrejected">Syntactic sugar for onRejected<a class="anchor" aria-label="anchor" href="#syntactic-sugar-for-onrejected"></a>
</h3>
<p>The same syntactic sugar that is offered for non-error cases, is
available for error handling code as well. You can use formulas in
<code>onRejected()</code>:</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://mirai.r-lib.org/reference/mirai.html" class="external-link">mirai</a></span><span class="op">(</span><span class="fu">somepkg</span><span class="fu">::</span><span class="fu">operation</span><span class="op">(</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/then.html">then</a></span><span class="op">(</span>onRejected <span class="op">=</span> \<span class="op">(</span><span class="va">err</span><span class="op">)</span> <span class="kw"><a href="https://rdrr.io/r/base/warning.html" class="external-link">warning</a></span><span class="op">(</span><span class="va">err</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>There’s a <code><a href="../reference/then.html">catch()</a></code> function that is just a shorthand for
<code>then(onRejected)</code>. It saves a little typing, but more
importantly, is easier to read:</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://mirai.r-lib.org/reference/mirai.html" class="external-link">mirai</a></span><span class="op">(</span><span class="fu">somepkg</span><span class="fu">::</span><span class="fu">operation</span><span class="op">(</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/then.html">catch</a></span><span class="op">(</span><span class="va">warning</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="error-tee">Error tee<a class="anchor" aria-label="anchor" href="#error-tee"></a>
</h3>
<p>Because it’s fairly common to want to do something with an error
without stopping it from propagating (such as logging), there are a
couple of additional shorthands for doing so without having to
explicitly call <code>stop(err)</code>. For example:</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">promise</span> <span class="op">|&gt;</span> <span class="fu"><a href="../reference/then.html">catch</a></span><span class="op">(</span><span class="va">print</span><span class="op">)</span></span></code></pre></div>
<p>will print the error, but also eat it. To print the error without
eating it, you’d have to do this:</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">promise</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/then.html">catch</a></span><span class="op">(</span>\<span class="op">(</span><span class="va">err</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">err</span><span class="op">)</span></span>
<span>    <span class="kw"><a href="https://rdrr.io/r/base/stop.html" class="external-link">stop</a></span><span class="op">(</span><span class="va">err</span><span class="op">)</span></span>
<span>  <span class="op">}</span><span class="op">)</span></span></code></pre></div>
<p>That’s a fair amount of boilerplate. Instead, you can either add
<code>tee = TRUE</code> to your <code>catch</code> call. These two lines
are equivalent to the previous code chunk:</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">promise</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/then.html">catch</a></span><span class="op">(</span><span class="va">print</span>, tee <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="cleaning-up-with-finally">Cleaning up with <code>finally</code><a class="anchor" aria-label="anchor" href="#cleaning-up-with-finally"></a>
</h2>
<p>In synchronous programming, you use
either<code>tryCatch(expr, finally = ...)</code> or
<code>on.exit(...)</code> to perform tasks (usually relating to freeing
resources or reverting temporary changes) regardless of whether the main
logic succeeds or fails (throws an error). When programming with
promises, you can use the <code><a href="../reference/then.html">finally()</a></code> call to do the same.
The <code><a href="../reference/then.html">finally()</a></code> function is similar to <code><a href="../reference/then.html">then()</a></code>
but it only takes a single callback that executes on both success and
failure, and its return value is ignored.</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">file_path</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/tempfile.html" class="external-link">tempfile</a></span><span class="op">(</span>fileext <span class="op">=</span> <span class="st">".png"</span><span class="op">)</span></span>
<span><span class="va">png_bytes_promise</span> <span class="op">&lt;-</span></span>
<span>  <span class="fu"><a href="https://mirai.r-lib.org/reference/mirai.html" class="external-link">mirai</a></span><span class="op">(</span></span>
<span>    <span class="op">{</span></span>
<span>      <span class="fu"><a href="https://rdrr.io/r/grDevices/png.html" class="external-link">png</a></span><span class="op">(</span><span class="va">file_path</span><span class="op">)</span></span>
<span>      <span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">cars</span><span class="op">)</span></span>
<span>      <span class="fu"><a href="https://rdrr.io/r/grDevices/dev.html" class="external-link">dev.off</a></span><span class="op">(</span><span class="op">)</span></span>
<span>      <span class="va">file_path</span></span>
<span>    <span class="op">}</span>,</span>
<span>    file_path <span class="op">=</span> <span class="va">file_path</span></span>
<span>  <span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/then.html">then</a></span><span class="op">(</span>\<span class="op">(</span><span class="op">)</span> <span class="fu">brio</span><span class="fu">::</span><span class="fu"><a href="https://brio.r-lib.org/reference/read_file.html" class="external-link">read_file_raw</a></span><span class="op">(</span><span class="va">file_path</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/then.html">finally</a></span><span class="op">(</span>\<span class="op">(</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/unlink.html" class="external-link">unlink</a></span><span class="op">(</span><span class="va">file_path</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>In this example, we need a temp file for the duration of the
pipeline. Our <code><a href="../reference/then.html">finally()</a></code> code expression makes sure the temp
file is deleted when the operation is done, regardless of whether it
succeeded or failed.</p>
<div style="font-size: 20px; margin-top: 40px; text-align: right;">
<p>Next: <a href="promises_04_mirai.html">Launching tasks</a></p>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Joe Cheng, Barret Schloerke, Winston Chang, Charlie Gao, Posit Software, PBC.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer>
</div>





  </body>
</html>
