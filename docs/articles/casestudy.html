<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Case study: converting a Shiny app to async • promises</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/cosmo/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js" integrity="sha384-cV+rhyOuRHc9Ub/91rihWcGmMmCXDeksTtCihMupQHSsi8GIIRDG0ThDc3HGQFJ3" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><meta property="og:title" content="Case study: converting a Shiny app to async">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">promises</a>
        <span class="label label-default" data-toggle="tooltip" data-placement="bottom" title="Released package">1.0.1.9000</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home"></span>
     
    Home
  </a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Learning
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/motivation.html">1. Why use promises?</a>
    </li>
    <li>
      <a href="../articles/intro.html">2. An informal intro to async programming</a>
    </li>
    <li>
      <a href="../articles/overview.html">3. Working with promises</a>
    </li>
    <li>
      <a href="../articles/futures.html">4. Launching tasks</a>
    </li>
    <li>
      <a href="../articles/shiny.html">5. Using promises with Shiny</a>
    </li>
    <li>
      <a href="../articles/combining.html">6. Combining promises</a>
    </li>
    <li>
      <a href="../articles/casestudy.html">7. Case study: Converting a Shiny app to async</a>
    </li>
  </ul>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/rstudio/promises">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1>Case study: converting a Shiny app to async</h1>
                        <h4 class="author">Joe Cheng (<a href="mailto:joe@rstudio.com">joe@rstudio.com</a>)</h4>
            
      
      <small>Source: <a href="https://github.com/rstudio/promises/blob/master/vignettes/casestudy.Rmd"><code>vignettes/casestudy.Rmd</code></a></small>

    </div>

    
    
<div class="contents">
<p>In this case study, we’ll work through an application of reasonable complexity, turning its slowest operations into futures/promises and modifying all the downstream reactive expressions and outputs to deal with promises.</p>
<div id="motivation" class="section level2">
<h2 class="hasAnchor">
<a href="#motivation" class="anchor"></a>Motivation</h2>
<blockquote>
<p>As a web service increases in popularity, so does the number of rogue scripts that abuse it for no apparent reason.</p>
<p><em>—Cheng’s Law of Why We Can’t Have Nice Things</em></p>
</blockquote>
<p>I first noticed this in 2011, when the then-new RStudio IDE was starting to gather steam. We had a dashboard that tracked how often RStudio was being downloaded, and the numbers were generally tracking smoothly upward. But once every few months, we’d have huge spikes in the download counts, ten times greater than normal—and invariably, we’d find that all of the unexpected increase could be tracked to one or two IP addresses.</p>
<p>For hours or days we’d be inundated with thousands of downloads per hour, then just as suddenly, they’d cease. I didn’t know what was happening then, and I still don’t know today. Was it the world’s least competent denial-of-service attempt? Did someone write a download script with an accidental <code>while (TRUE)</code> around it?</p>
<p>Our application will let us examine downloads from CRAN for this kind of behavior. For any given day on CRAN, we’ll see what the top downloaders are and how they’re behaving.</p>
</div>
<div id="our-source-data" class="section level2">
<h2 class="hasAnchor">
<a href="#our-source-data" class="anchor"></a>Our source data</h2>
<p>RStudio maintains the popular <code>0-Cloud</code> CRAN mirror, and the log files it generates are freely available at <a href="http://cran-logs.rstudio.com/" class="uri">http://cran-logs.rstudio.com/</a>. Each day is a separate gzipped CSV file, and each row is a single package download. For privacy, IP addresses are anonymized by substituting each day’s IP addresses with unique integer IDs.</p>
<p>Here are the first few lines of <a href="http://cran-logs.rstudio.com/2018/2018-05-26.csv.gz" class="uri">http://cran-logs.rstudio.com/2018/2018-05-26.csv.gz</a>:</p>
<pre><code>JMC15-2017:cranwhales jcheng$ zless data_cache/2018-05-26.csv.gz
"date","time","size","r_version","r_arch","r_os","package","version","country","ip_id"
"2018-05-26","20:42:23",450377,"3.4.4","x86_64","linux-gnu","lubridate","1.7.4","NL",1
"2018-05-26","20:42:30",484348,NA,NA,NA,"homals","0.9-7","GB",2
"2018-05-26","20:42:21",98484,"3.3.1","x86_64","darwin13.4.0","miniUI","0.1.1.1","NL",1
"2018-05-26","20:42:27",518,"3.4.4","x86_64","linux-gnu","RCurl","1.95-4.10","US",3</code></pre>
<p>Fortunately for our purposes, there’s no need to analyze these logs at a high level to figure out which days are affected by badly behaved download scripts. These CRAN mirrors are popular enough that, according to Cheng’s Law, there should be plenty of rogue scripts hitting it every day of the year.</p>
</div>
<div id="a-tour-of-the-app" class="section level2">
<h2 class="hasAnchor">
<a href="#a-tour-of-the-app" class="anchor"></a>A tour of the app</h2>
<p>The app I built to explore this data, <strong>cranwhales</strong>, let us examine the behavior of the top downloaders (“whales”) for any given day, at varying levels of detail. You can view this app live at <a href="https://jcheng.shinyapps.io/cranwhales/" class="uri">https://jcheng.shinyapps.io/cranwhales/</a>, or download and run the code yourself at <a href="https://github.com/rstudio/cranwhales" class="uri">https://github.com/rstudio/cranwhales</a>.</p>
<p>When the app starts, the “All traffic” tab shows you the number of package downloads per hour for all users vs. whales. In this screenshot, you can see the proportion of files downloaded by the top six downloaders on May 28, 2018. It may not look like a huge fraction at first, but keep in mind, we are only talking about six downloaders out of 52,815 total!</p>
<p><img src="case-study-tab1.png"></p>
<p>The “Biggest whales” tab simply shows the most prolific downloaders, with their number of downloads performed. Each anonymized IP address has been assigned an easier-to-remember name, and you can also see the country code of the original IP address.</p>
<p><img src="case-study-tab2.png"></p>
<p>The “Whales by hour” tab shows the hourly download counts for each whale individually. In this screenshot, you can see that the Netherlands’ <code>relieved_snake</code> downloaded at an extremely consistent rate during the whole day, while the American <code>curly_capabara</code> was active only during business hours in Eastern Standard Time. Still others, like <code>colossal_chicken</code> out of Hong Kong, was busy all day but at varying rates.</p>
<p><img src="case-study-tab3.png"></p>
<p>The “Detail View” has perhaps the most illuminating information. It lets you view every download made by a given whale on the day in question. The x dimension is time and the y dimension is what package they downloaded, so you can see at a glance exactly how many packages were downloaded, and how their various package downloads relate to each other. In this case, <code>relieved_snake</code> downloaded 104 different packages, in the same order, continuously, for the entire day.</p>
<p><img src="case-study-tab4.png"></p>
<p>Others behave very differently, like <code>freezing_tapir</code>, who downloaded <code>devtools</code>–and <em>only</em> <code>devtools</code>–for the whole day, racking up 19,180 downloads totalling 7.9 gigabytes for that one package alone!</p>
<p><img src="case-study-tab5.png"></p>
<p>Sadly, the app can’t tell us any more than that–it can’t explain <em>why</em> these downloaders are behaving this way, nor can it tell us their street addresses so that we can send ninjas in black RStudio helicoptors to make them stop.</p>
</div>
<div id="the-implementation" class="section level2">
<h2 class="hasAnchor">
<a href="#the-implementation" class="anchor"></a>The implementation</h2>
<p>Now that you’ve seen what the app does, let’s talk about how it was implemented, then convert it from sync to async.</p>
<div id="user-interface" class="section level3">
<h3 class="hasAnchor">
<a href="#user-interface" class="anchor"></a>User interface</h3>
<p>The user interface is a pretty typical shinydashboard. It’s important to note that the UI part of the app is entirely agnostic to whether the server is written in the sync or async style; when we port the app to async, we won’t touch the UI at all.</p>
<p>There are two major pieces of input we need from users: what <strong>date</strong> to examine (this app only lets us look at one day at a time) and <strong>how many</strong> of the most prolific downloaders to look at. We’ll put these two controls in the dashboard sidebar.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">dashboardSidebar</span>(</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  <span class="kw">dateInput</span>(<span class="st">"date"</span>, <span class="st">"Date"</span>, <span class="dt">value =</span> <span class="kw">Sys.Date</span>() <span class="op">-</span><span class="st"> </span><span class="dv">2</span>),</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  <span class="kw">numericInput</span>(<span class="st">"count"</span>, <span class="st">"Show top N downloaders:"</span>, <span class="dv">6</span>)</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">)</a></code></pre></div>
<p>(We set <code>date</code> to two days ago by default, because there’s some lag between when a day ends and when its logs are published.)</p>
<p>The rest of the UI code is just typical shinydashboard scaffolding, plus some <code><a href="http://www.rdocumentation.org/packages/shinydashboard/topics/valueBoxOutput">shinydashboard::valueBoxOutput</a></code>s and <code>plotOutputs</code>. These are so trivial that they’re hardly worth talking about, but I’ll include the code here for completeness. Finally, there’s <code>detailViewUI</code>, a <a href="https://shiny.rstudio.com/articles/modules.html">Shiny module</a> that just contains more of the same (value boxes and plots).</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" data-line-number="1">  <span class="kw">dashboardBody</span>(</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">    <span class="kw">fluidRow</span>(</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">      <span class="kw">tabBox</span>(<span class="dt">width =</span> <span class="dv">12</span>,</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">        <span class="kw">tabPanel</span>(<span class="st">"All traffic"</span>,</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">          <span class="kw">fluidRow</span>(</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">            <span class="kw">valueBoxOutput</span>(<span class="st">"total_size"</span>, <span class="dt">width =</span> <span class="dv">4</span>),</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">            <span class="kw">valueBoxOutput</span>(<span class="st">"total_count"</span>, <span class="dt">width =</span> <span class="dv">4</span>),</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">            <span class="kw">valueBoxOutput</span>(<span class="st">"total_downloaders"</span>, <span class="dt">width =</span> <span class="dv">4</span>)</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">          ),</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">          <span class="kw">plotOutput</span>(<span class="st">"all_hour"</span>)</a>
<a class="sourceLine" id="cb3-11" data-line-number="11">        ),</a>
<a class="sourceLine" id="cb3-12" data-line-number="12">        <span class="kw">tabPanel</span>(<span class="st">"Biggest whales"</span>,</a>
<a class="sourceLine" id="cb3-13" data-line-number="13">          <span class="kw">plotOutput</span>(<span class="st">"downloaders"</span>, <span class="dt">height =</span> <span class="dv">500</span>)</a>
<a class="sourceLine" id="cb3-14" data-line-number="14">        ),</a>
<a class="sourceLine" id="cb3-15" data-line-number="15">        <span class="kw">tabPanel</span>(<span class="st">"Whales by hour"</span>,</a>
<a class="sourceLine" id="cb3-16" data-line-number="16">          <span class="kw">plotOutput</span>(<span class="st">"downloaders_hour"</span>, <span class="dt">height =</span> <span class="dv">500</span>)</a>
<a class="sourceLine" id="cb3-17" data-line-number="17">        ),</a>
<a class="sourceLine" id="cb3-18" data-line-number="18">        <span class="kw">tabPanel</span>(<span class="st">"Detail view"</span>,</a>
<a class="sourceLine" id="cb3-19" data-line-number="19">          <span class="kw">detailViewUI</span>(<span class="st">"details"</span>)</a>
<a class="sourceLine" id="cb3-20" data-line-number="20">        )</a>
<a class="sourceLine" id="cb3-21" data-line-number="21">      )</a>
<a class="sourceLine" id="cb3-22" data-line-number="22">    )</a>
<a class="sourceLine" id="cb3-23" data-line-number="23">  )</a></code></pre></div>
</div>
<div id="server-logic" class="section level3">
<h3 class="hasAnchor">
<a href="#server-logic" class="anchor"></a>Server logic</h3>
<p>Based on these inputs and outputs, we’ll write a variety of reactive expressions and output renderers to download, manipulate, and visualize the relevant log data.</p>
<p>The reactive expressions:</p>
<ul>
<li>
<code>data</code> (<code>eventReactive</code>): Whenever <code>input$date</code> changes, the <code>data</code> reactive downloads the full log for that day from <a href="http://cran-logs.rstudio.com" class="uri">http://cran-logs.rstudio.com</a>, and parses it.</li>
<li>
<code>whales</code> (<code>reactive</code>): Reads from <code>data()</code>, tallies the number of downloads performed by each unique IP, and returns a data frame of the top <code>input$count</code> most prolific downloaders, along with their download counts.</li>
<li>
<code>whale_downloads</code> (<code>reactive</code>): Joins the <code>data()</code> and <code>whales()</code> data frames, to return all of the details of the cetacean downloads.</li>
</ul>
<p>In terms of reactive dependencies, <code>data =&gt; whales</code>, and <code>data + whales =&gt; whale_downloads</code>. [TODO: make a diagram]</p>
<p>The outputs in this app are mostly either <code>renderPlot</code>s that we populate with <code>ggplot2</code>, or <code><a href="http://www.rdocumentation.org/packages/shinydashboard/topics/renderValueBox">shinydashboard::renderValueBox</a></code>es. They all rely on one or more of the reactive expressions we just described. We won’t catalog them all here, as they’re not individually interesting, but we will look at some archetypes below.</p>
</div>
</div>
<div id="converting-to-async" class="section level2">
<h2 class="hasAnchor">
<a href="#converting-to-async" class="anchor"></a>Converting to async</h2>
<p>To quote the article <a href="https://rstudio.github.io/promises/articles/shiny.html"><em>Using promises with Shiny</em></a>, async programming with Shiny boils down to following a few steps:</p>
<ol style="list-style-type: decimal">
<li>Identify slow operations in your app.</li>
<li>Convert the slow operations into futures.</li>
<li>Any code that relies on the result of those operations (if any), whether directly or indirectly, now must be converted to promise handlers that operate on the future object.</li>
</ol>
<p>In this case, the slow operations are easy to identify: the downloading and parsing that takes place in the <code>data</code> reactive expression can each take several long seconds.</p>
<p>Converting the download and parsing operations into futures turns out to be the most complicated part of the process, for reasons we’ll get into later.</p>
<p>Assuming we do that successfully, the <code>data</code> reactive expression will no longer return a data frame, but a <code>promise</code> object (that resolves to a data frame). Since the <code>whales</code> and <code>whale_downloads</code> reactive expressions both rely on <code>data</code>, those will both also need to be converted to read and return <code>promise</code> objects. And therefore, because the outputs all rely on one or more reactive expressions, they will all need to know how to deal with <code>promise</code> objects.</p>
<p>Async code is infectious like that; once you turn the heart of your app into a promise, everything downstream must become promise-aware as well, all the way through to the observers and outputs.</p>
<p>With that overview out of the way, let’s dive into the code.</p>
<p>In the sections below, we’ll take a look at the code behind some outputs and reactive expressions. For each element, we’ll look first at the sync version, then the async version.</p>
<p>In some cases, these code snippets may be slightly abridged. See the <a href="https://github.com/rstudio/cranwhales">GitHub repository</a> for the full code.</p>
<p>Until you’ve received an introduction to the <code>%...&gt;%</code> operator, the async code below will make no sense, so if you haven’t read <a href="https://rstudio.github.io/promises/articles/intro.html"><em>An informal intro to async programming</em></a> and/or <a href="https://rstudio.github.io/promises/articles/overview.html"><em>Working with promises in R</em></a>, I highly recommend doing so before continuing!</p>
<div id="loading-promises-and-future" class="section level3">
<h3 class="hasAnchor">
<a href="#loading-promises-and-future" class="anchor"></a>Loading <code>promises</code> and <code>future</code>
</h3>
<p>The first thing we’ll do is load the basic libraries of async programming.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">library</span>(promises)</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="kw">library</span>(future)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="kw"><a href="http://www.rdocumentation.org/packages/future/topics/plan">plan</a></span>(multisession)</a></code></pre></div>
<p>I originally used <code>multiprocess</code> but file downloading inside a future seemed to fail on Mac. (I’ve found that it’s usually not worth spending a lot of time trying to figure out why <code>multiprocess</code> doesn’t work for some specific code; instead, just use <code>multisession</code>, since that’s probably going to be the solution anyway.)</p>
</div>
<div id="the-data-reactive-future-all-the-things" class="section level3">
<h3 class="hasAnchor">
<a href="#the-data-reactive-future-all-the-things" class="anchor"></a>The <code>data</code> reactive: future() all the things</h3>
<p>The next thing we’ll do is convert the <code>data</code> event reactive to use <code>future</code> for the expensive bits. The original code looks lke this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co"># SYNCHRONOUS version</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">data &lt;-<span class="st"> </span><span class="kw">eventReactive</span>(input<span class="op">$</span>date, {</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  date &lt;-<span class="st"> </span>input<span class="op">$</span>date  <span class="co"># Example: 2018-05-28</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  year &lt;-<span class="st"> </span>lubridate<span class="op">::</span><span class="kw"><a href="http://lubridate.tidyverse.org/reference/year.html">year</a></span>(date)  <span class="co"># Example: "2018"</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">  </a>
<a class="sourceLine" id="cb5-7" data-line-number="7">  url &lt;-<span class="st"> </span><span class="kw">glue</span>(<span class="st">"http://cran-logs.rstudio.com/{year}/{date}.csv.gz"</span>)</a>
<a class="sourceLine" id="cb5-8" data-line-number="8">  path &lt;-<span class="st"> </span><span class="kw">file.path</span>(<span class="st">"data_cache"</span>, <span class="kw">paste0</span>(date, <span class="st">".csv.gz"</span>))</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">  </a>
<a class="sourceLine" id="cb5-10" data-line-number="10">  <span class="kw">withProgress</span>(<span class="dt">value =</span> <span class="ot">NULL</span>, {</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">    </a>
<a class="sourceLine" id="cb5-12" data-line-number="12">    <span class="cf">if</span> (<span class="op">!</span><span class="kw">file.exists</span>(path)) {</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">      <span class="kw">setProgress</span>(<span class="dt">message =</span> <span class="st">"Downloading data..."</span>)</a>
<a class="sourceLine" id="cb5-14" data-line-number="14">      <span class="kw">download.file</span>(url, path)</a>
<a class="sourceLine" id="cb5-15" data-line-number="15">    }</a>
<a class="sourceLine" id="cb5-16" data-line-number="16">    </a>
<a class="sourceLine" id="cb5-17" data-line-number="17">    <span class="kw">setProgress</span>(<span class="dt">message =</span> <span class="st">"Parsing data..."</span>)</a>
<a class="sourceLine" id="cb5-18" data-line-number="18">    <span class="kw">read_csv</span>(path, <span class="dt">col_types =</span> <span class="st">"Dti---c-ci"</span>, <span class="dt">progress =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb5-19" data-line-number="19"></a>
<a class="sourceLine" id="cb5-20" data-line-number="20">  })</a>
<a class="sourceLine" id="cb5-21" data-line-number="21">})</a></code></pre></div>
<p>For now, we’ll lose the <code>withProgress</code>/<code>setProgress</code> reporting, since doing that correctly requires some more advanced techniques that we’ll talk about later. We’ll come back and fix this code later, but for now:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="co"># ASYNCHRONOUS version</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">data &lt;-<span class="st"> </span><span class="kw">eventReactive</span>(input<span class="op">$</span>date, {</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  date &lt;-<span class="st"> </span>input<span class="op">$</span>date  </a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  year &lt;-<span class="st"> </span>lubridate<span class="op">::</span><span class="kw"><a href="http://lubridate.tidyverse.org/reference/year.html">year</a></span>(date)</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">  </a>
<a class="sourceLine" id="cb6-7" data-line-number="7">  url &lt;-<span class="st"> </span><span class="kw">glue</span>(<span class="st">"http://cran-logs.rstudio.com/{year}/{date}.csv.gz"</span>)</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  path &lt;-<span class="st"> </span><span class="kw">file.path</span>(<span class="st">"data_cache"</span>, <span class="kw">paste0</span>(date, <span class="st">".csv.gz"</span>))</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  </a>
<a class="sourceLine" id="cb6-10" data-line-number="10">  <span class="kw"><a href="http://www.rdocumentation.org/packages/future/topics/future">future</a></span>({</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">    <span class="cf">if</span> (<span class="op">!</span><span class="kw">file.exists</span>(path)) {</a>
<a class="sourceLine" id="cb6-12" data-line-number="12">      <span class="kw">download.file</span>(url, path)</a>
<a class="sourceLine" id="cb6-13" data-line-number="13">    }</a>
<a class="sourceLine" id="cb6-14" data-line-number="14">    <span class="kw">read_csv</span>(path, <span class="dt">col_types =</span> <span class="st">"Dti---c-ci"</span>, <span class="dt">progress =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb6-15" data-line-number="15">  })</a>
<a class="sourceLine" id="cb6-16" data-line-number="16">})</a></code></pre></div>
<p>Pretty straightforward. This reactive now returns a future (which counts as a promise), not a data frame.</p>
<p>Remember that we <strong>must</strong> read any reactive values (including <code>input</code>) and reactive expressions <a href="https://rstudio.github.io/promises/articles/shiny.html#shiny-specific-caveats-and-limitations">from <strong>outside</strong> the future</a>. (You will get an error if you attempt to read one from inside the future.)</p>
<p>At this point, since there are no other long-running operations we want to make asynchronous, we’re actually done interacting directly with the <code>future</code> package. The rest of the reactive expressions will deal with the future returned by <code>data</code> using general async functions and operators from <code>promises</code>.</p>
</div>
<div id="the-whales-reactive-simple-pipelines-are-simple" class="section level3">
<h3 class="hasAnchor">
<a href="#the-whales-reactive-simple-pipelines-are-simple" class="anchor"></a>The <code>whales</code> reactive: simple pipelines are simple</h3>
<p>The <code>whales</code> reactive takes the data frame from <code>data</code>, and uses dplyr to find the top <code>input$count</code> most prolific downloaders.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="co"># SYNCHRONOUS version</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">whales &lt;-<span class="st"> </span><span class="kw">reactive</span>({</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  <span class="kw">data</span>() <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5"><span class="st">    </span><span class="kw">count</span>(ip_id) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6"><span class="st">    </span><span class="kw">arrange</span>(<span class="kw">desc</span>(n)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7"><span class="st">    </span><span class="kw">head</span>(input<span class="op">$</span>count)</a>
<a class="sourceLine" id="cb7-8" data-line-number="8">})</a></code></pre></div>
<p>Since <code>data()</code> now returns a promise, the whole function needs to be modified to deal with promises.</p>
<p>This is basically a best-case scenario for working with <code>promises</code>. The whole expression consists of a single magrittr pipeline. There’s only one object (<code>data()</code>) that’s been converted to a promise. The promise object only appears once, at the head of the pipeline.</p>
<p>When the stars align like this, converting this code to async is literally as easy as replacing each <code>%&gt;%</code> with <code>%...&gt;%</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="co"># ASYNCHRONOUS version</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">whales &lt;-<span class="st"> </span><span class="kw">reactive</span>({</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  <span class="kw">data</span>() <span class="op">%...&gt;%</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="st">    </span><span class="kw">count</span>(ip_id) <span class="op">%...&gt;%</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6"><span class="st">    </span><span class="kw">arrange</span>(<span class="kw">desc</span>(n)) <span class="op">%...&gt;%</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="st">    </span><span class="kw">head</span>(input<span class="op">$</span>count)</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">})</a></code></pre></div>
<p>The input (<code>data()</code>) is a promise, the resulting output object is a promise, each stage of the pipeline returns a promise; but we can read and write this code almost as easily as the synchronous version!</p>
<p>An example this simple may seem reductive, but this best-case scenario happens surprisingly often, if your coding style is influenced by the tidyverse. In this example app, <strong>59%</strong> of the reactives, observers, and outputs were converted using nothing more than replacing <code>%&gt;%</code> with <code>%...&gt;%</code>.</p>
<p>One last thing before we move on. In the last section, I emphasized that reactive values cannot be read from inside a future. Here, we’re using <code>head(input$count)</code> inside a promise-pipeline; since <code>data()</code> is written using a future, doesn’t that mean… well… isn’t this wrong?</p>
<p>Nope—this code is just fine. The prohibition is against reading reactive values/expressions from <em>inside</em> a future, because code inside a future is executed in a totally different R process. The steps in a promise-pipeline aren’t futures, but promise handlers. These aren’t executed in a different process; rather, they’re executed back in the original R process after a promise is resolved. We’re allowed and expected to access reactive values and expressions from these handlers.</p>
</div>
<div id="the-whale_downloads-reactive-reading-from-multiple-promises" class="section level3">
<h3 class="hasAnchor">
<a href="#the-whale_downloads-reactive-reading-from-multiple-promises" class="anchor"></a>The <code>whale_downloads</code> reactive: reading from multiple promises</h3>
<p>The <code>whale_downloads</code> reactive is a bit more complicated case.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="co"># SYNCHRONOUS version</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">whale_downloads &lt;-<span class="st"> </span><span class="kw">reactive</span>({</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  <span class="kw">data</span>() <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="st">    </span><span class="kw">inner_join</span>(<span class="kw">whales</span>(), <span class="st">"ip_id"</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6"><span class="st">    </span><span class="kw">select</span>(<span class="op">-</span>n)</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">})</a></code></pre></div>
<p>Looks simple, but we can’t just do a simple replacement this time. Can you see why?</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="co"># BAD VERSION DOESN'T WORK</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">whale_downloads &lt;-<span class="st"> </span><span class="kw">reactive</span>({</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  <span class="kw">data</span>() <span class="op">%...&gt;%</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="st">    </span><span class="kw">inner_join</span>(<span class="kw">whales</span>(), <span class="st">"ip_id"</span>) <span class="op">%...&gt;%</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6"><span class="st">    </span><span class="kw">select</span>(<span class="op">-</span>n)</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">})</a></code></pre></div>
<p>Remember, both <code>data()</code> and <code>whales()</code> now return a promise object, not a data frame. None of the dplyr verbs know how to deal with promises natively (and the same is true for almost every other R function, anywhere in the R universe).</p>
<p>We’re able to use <code>%...&gt;%</code> with promises on the left-hand side and regular dplyr calls on the right-hand side, only because the <code>%...&gt;%</code> operator “unwraps” the promise object for us, yielding a regular object (data frame or whatever) to be passed to dplyr. But in this case, we’re passing <code>whales()</code>, which a promise object, directly to <code>inner_join</code>, and <code>inner_join</code> has no idea what to do with it.</p>
<p>The fundamental thing to pattern-match on here, is that <strong>we have a block of code that relies on more than one promise object</strong>, and that means <code>%...&gt;%</code> won’t be enough. This is a pretty common situation as well, and occurs in <strong>12%</strong> of reactives and outputs in this example app.</p>
<p>Here’s what the real solution looks like:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="co"># ASYNCHRONOUS version</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">whale_downloads &lt;-<span class="st"> </span><span class="kw">reactive</span>({</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  <span class="kw"><a href="../reference/promise_all.html">promise_all</a></span>(<span class="dt">data =</span> <span class="kw">data</span>(), <span class="dt">whales =</span> <span class="kw">whales</span>()) <span class="op">%...&gt;%</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5"><span class="st">    </span><span class="kw">with</span>({</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">      data <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7"><span class="st">        </span><span class="kw">inner_join</span>(whales, <span class="st">"ip_id"</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb11-8" data-line-number="8"><span class="st">        </span><span class="kw">select</span>(<span class="op">-</span>n)</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">    })</a>
<a class="sourceLine" id="cb11-10" data-line-number="10">})</a></code></pre></div>
<div id="promises-the-gathering" class="section level4">
<h4 class="hasAnchor">
<a href="#promises-the-gathering" class="anchor"></a>Promises: the Gathering</h4>
<p>This solution uses the <a href="https://rstudio.github.io/promises/articles/combining.html#gathering">promise gathering</a> pattern, which combines <code>promises_all</code>, <code>%...&gt;%</code>, and <code>with</code>.</p>
<ul>
<li>The <code>promise_all</code> function gathers multiple promise objects together, and returns a single promise object. This new promise object doesn’t resolve until all the input promise objects are resolved, and it yields a list of those results.</li>
</ul>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="op">&gt;</span><span class="st"> </span><span class="kw"><a href="../reference/promise_all.html">promise_all</a></span>(<span class="dt">a =</span> <span class="kw"><a href="http://www.rdocumentation.org/packages/future/topics/future">future</a></span>(<span class="st">"Hello"</span>), <span class="dt">b =</span> <span class="kw"><a href="http://www.rdocumentation.org/packages/future/topics/future">future</a></span>(<span class="st">"World"</span>)) <span class="op">%...&gt;%</span><span class="st"> </span><span class="kw">print</span>()</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="op">$</span>a</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">[<span class="dv">1</span>] <span class="st">"Hello"</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4"></a>
<a class="sourceLine" id="cb12-5" data-line-number="5"><span class="op">$</span>b</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">[<span class="dv">1</span>] <span class="st">"World"</span></a></code></pre></div>
<ul>
<li>The <code>%...&gt;%</code>, as before, “unwraps” the promise object and passes the result to its right hand side.</li>
<li>The <code>with</code> function (from base R) takes a named list, and makes it into a sort of virtual parent environment while evaluating a code block you pass it.</li>
</ul>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="op">&gt;</span><span class="st"> </span>x <span class="op">+</span><span class="st"> </span>y</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">Error<span class="op">:</span><span class="st"> </span>object <span class="st">'x'</span> not found</a>
<a class="sourceLine" id="cb13-3" data-line-number="3"></a>
<a class="sourceLine" id="cb13-4" data-line-number="4"><span class="op">&gt;</span><span class="st"> </span><span class="kw">with</span>(<span class="kw">list</span>(<span class="dt">x =</span> <span class="dv">1</span>, <span class="dt">y =</span> <span class="dv">2</span>), {</a>
<a class="sourceLine" id="cb13-5" data-line-number="5"><span class="op">+</span><span class="st">   </span>x <span class="op">+</span><span class="st"> </span>y</a>
<a class="sourceLine" id="cb13-6" data-line-number="6"><span class="op">+</span><span class="st"> </span>})</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">[<span class="dv">1</span>] <span class="dv">3</span></a></code></pre></div>
<p>Let’s once again combine the three, with the simplest possible example of the gathering pattern:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="op">&gt;</span><span class="st"> </span><span class="kw"><a href="../reference/promise_all.html">promise_all</a></span>(<span class="dt">x =</span> <span class="kw"><a href="http://www.rdocumentation.org/packages/future/topics/future">future</a></span>(<span class="st">"Hello"</span>), <span class="dt">y =</span> <span class="kw"><a href="http://www.rdocumentation.org/packages/future/topics/future">future</a></span>(<span class="st">"World"</span>)) <span class="op">%...&gt;%</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="op">+</span><span class="st">   </span><span class="kw">with</span>({ <span class="kw">paste</span>(x, y) }) <span class="op">%...&gt;%</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3"><span class="op">+</span><span class="st">   </span><span class="kw">print</span>()</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">[<span class="dv">1</span>] <span class="st">"Hello World"</span></a></code></pre></div>
<p>You can make use of this pattern without remembering exactly how these pieces combine. Just remember that the arguments to <code>promise_all</code> provide the promise objects (<code><a href="http://www.rdocumentation.org/packages/future/topics/future">future(1)</a></code> and <code><a href="http://www.rdocumentation.org/packages/future/topics/future">future(2)</a></code>), along with the names you want to use to refer to their yielded values (<code>x</code> and <code>y</code>); and the code block you put in <code>with()</code> can refer to those names without worrying about the fact that they were ever promises to begin with.</p>
</div>
</div>
<div id="the-total_downloaders-value-box-simple-pipelines-are-for-output-too" class="section level3">
<h3 class="hasAnchor">
<a href="#the-total_downloaders-value-box-simple-pipelines-are-for-output-too" class="anchor"></a>The <code>total_downloaders</code> value box: simple pipelines are for output, too</h3>
<p><img src="case-study-downloaders.png"></p>
<p>All of the value boxes in this app ended up looking a lot like this:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="co"># SYNCHRONOUS version</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">output<span class="op">$</span>total_downloaders &lt;-<span class="st"> </span><span class="kw">renderValueBox</span>({</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">  <span class="kw">data</span>() <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5"><span class="st">    </span><span class="kw">pull</span>(ip_id) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb15-6" data-line-number="6"><span class="st">    </span><span class="kw">unique</span>() <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7"><span class="st">    </span><span class="kw">length</span>() <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb15-8" data-line-number="8"><span class="st">    </span><span class="kw">format</span>(<span class="dt">big.mark =</span> <span class="st">","</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb15-9" data-line-number="9"><span class="st">    </span><span class="kw">valueBox</span>(<span class="st">"unique downloaders"</span>)</a>
<a class="sourceLine" id="cb15-10" data-line-number="10">})</a></code></pre></div>
<p>This is structurally no different than the <code>whales</code> best-case scenario reactive. One thing worth pointing out is that an async <code>renderValueBox</code> means you return a promise that returns a <code>valueBox</code>; you <em>don’t</em> return a <code>valueBox</code> to whom you have passed a promise.</p>
<p>Meaning, you <em>don’t</em> do this:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="co"># BAD VERSION DOESN'T WORK</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">output<span class="op">$</span>total_downloaders &lt;-<span class="st"> </span><span class="kw">renderValueBox</span>({</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">  <span class="kw">valueBox</span>(</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">    <span class="kw">data</span>() <span class="op">%...&gt;%</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6"><span class="st">      </span><span class="kw">pull</span>(ip_id) <span class="op">%...&gt;%</span></a>
<a class="sourceLine" id="cb16-7" data-line-number="7"><span class="st">      </span><span class="kw">unique</span>() <span class="op">%...&gt;%</span></a>
<a class="sourceLine" id="cb16-8" data-line-number="8"><span class="st">      </span><span class="kw">length</span>() <span class="op">%...&gt;%</span></a>
<a class="sourceLine" id="cb16-9" data-line-number="9"><span class="st">      </span><span class="kw">format</span>(<span class="dt">big.mark =</span> <span class="st">","</span>),</a>
<a class="sourceLine" id="cb16-10" data-line-number="10">    <span class="st">"unique downloaders"</span></a>
<a class="sourceLine" id="cb16-11" data-line-number="11">  )</a>
<a class="sourceLine" id="cb16-12" data-line-number="12">})</a></code></pre></div>
<p>Instead, you do this:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="co"># ASYNCHRONOUS version</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2"></a>
<a class="sourceLine" id="cb17-3" data-line-number="3">output<span class="op">$</span>total_downloaders &lt;-<span class="st"> </span><span class="kw">renderValueBox</span>({</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  <span class="kw">data</span>() <span class="op">%...&gt;%</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5"><span class="st">    </span><span class="kw">pull</span>(ip_id) <span class="op">%...&gt;%</span></a>
<a class="sourceLine" id="cb17-6" data-line-number="6"><span class="st">    </span><span class="kw">unique</span>() <span class="op">%...&gt;%</span></a>
<a class="sourceLine" id="cb17-7" data-line-number="7"><span class="st">    </span><span class="kw">length</span>() <span class="op">%...&gt;%</span></a>
<a class="sourceLine" id="cb17-8" data-line-number="8"><span class="st">    </span><span class="kw">format</span>(<span class="dt">big.mark =</span> <span class="st">","</span>) <span class="op">%...&gt;%</span></a>
<a class="sourceLine" id="cb17-9" data-line-number="9"><span class="st">    </span><span class="kw">valueBox</span>(<span class="st">"unique downloaders"</span>)</a>
<a class="sourceLine" id="cb17-10" data-line-number="10">})</a></code></pre></div>
<p>The other trick worth nothing is the <code>pull</code> verb, which is used to retrieve a specific column of a data frame as a vector (similar to <code>$</code> or <code>[[</code>). In this case, <code>pull(data, ip_id)</code> is equivalent to <code>data[["ip_id"]]</code>. Note that <code>pull</code> is part of dplyr and isn’t specific to promises.</p>
</div>
<div id="the-biggest_whales-plot-getting-untidy" class="section level3">
<h3 class="hasAnchor">
<a href="#the-biggest_whales-plot-getting-untidy" class="anchor"></a>The <code>biggest_whales</code> plot: getting untidy</h3>
<p>In a cruel twist of API design fate, one of the cornerstone packages of the tidyverse lacks a tidy API. I’m referring, of course, to <code>ggplot2</code>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="co"># SYNCHRONOUS version</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2"></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">output<span class="op">$</span>downloaders &lt;-<span class="st"> </span><span class="kw">renderPlot</span>({</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">  <span class="kw">whales</span>() <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb18-5" data-line-number="5"><span class="st">    </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(ip_name, n)) <span class="op">+</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6"><span class="st">    </span><span class="kw">geom_bar</span>(<span class="dt">stat =</span> <span class="st">"identity"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb18-7" data-line-number="7"><span class="st">    </span><span class="kw">ylab</span>(<span class="st">"Downloads on this day"</span>)</a>
<a class="sourceLine" id="cb18-8" data-line-number="8">})</a></code></pre></div>
<p>While <code>dplyr</code> and other tidyverse packages are designed to link calls together with <code>%&gt;%</code>, the older <code>ggplot2</code> package uses the <code>+</code> operator. This is mostly a small aesthetic wart when synchronous code, but it’s a real problem with async, because the <code>promises</code> package doesn’t currently have a promise-aware replacement for <code>+</code> like it does for <code>%&gt;%</code>.</p>
<p>Fortunately, there’s a pretty good escape hatch for <code>%&gt;%</code>, and <code>%...&gt;%</code> inherited it too. Instead of a pipeline stage being a simple function call, you can put a <code>{</code> and <code>}</code> delimited code block, and inside of that code block, you can access the “it” value using a period (<code>.</code>).</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="co"># ASYNCHRONOUS version</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2"></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">output<span class="op">$</span>downloaders &lt;-<span class="st"> </span><span class="kw">renderPlot</span>({</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">  <span class="kw">whales</span>() <span class="op">%...&gt;%</span><span class="st"> </span>{</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">    whale_df &lt;-<span class="st"> </span>.</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">    <span class="kw">ggplot</span>(whale_df, <span class="kw">aes</span>(ip_name, n)) <span class="op">+</span></a>
<a class="sourceLine" id="cb19-7" data-line-number="7"><span class="st">      </span><span class="kw">geom_bar</span>(<span class="dt">stat =</span> <span class="st">"identity"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb19-8" data-line-number="8"><span class="st">      </span><span class="kw">ylab</span>(<span class="st">"Downloads on this day"</span>)</a>
<a class="sourceLine" id="cb19-9" data-line-number="9">  }</a>
<a class="sourceLine" id="cb19-10" data-line-number="10">})</a></code></pre></div>
<p><strong>The importance of this pattern cannot be overstated!</strong> Using <code>%...&gt;%</code> and simple calls alone, you’re restricted to doing pipeline-compatible operations. But <code>%...&gt;%</code> together with a curly-brace code block means your handler code can be any shape or size. Once inside that code block, you have a regular, non-promise value in <code>.</code> (if you even want to use it—sometimes you don’t, as we’ll see later). You can have zero, one, or more statements. You can use the <code>.</code> multiple times, in nested expressions, whatever.</p>
<p>Tip: if you have extensive or complex code to put in a code block, start the block by creating a properly named variable to store the value of <code>.</code>. The reason for this is that <code>.</code> may acquire a different meaning than you intend as you add code to the code block. For example, if a magrittr pipeline starts with <code>.</code>, instead of evaluating the pipeline and returning a value, it creates a function that takes a single argument. So the following code wouldn’t filter the resolved value of <code>whales()</code>, but instead, create an anonymous function that calls <code>filter(n &gt; 1000)</code> on whatever you pass it.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">whales</span>() <span class="op">%...&gt;%</span><span class="st"> </span>{</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">  . <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(n <span class="op">&gt;</span><span class="st"> </span><span class="dv">1000</span>)</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">}</a></code></pre></div>
<p>This fixes it:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">whales</span>() <span class="op">%...&gt;%</span><span class="st"> </span>{</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">  whales_df &lt;-<span class="st"> </span>.</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  whales_df <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(n <span class="op">&gt;</span><span class="st"> </span><span class="dv">1000</span>)</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">}</a></code></pre></div>
<p>There are other ways to work around the above problem as well, but I like this fix because it doesn’t require any thought or care. Just give the <code>.</code> value a new name, and forget the <code>.</code> exists.</p>
<p>For untidy code with a single promise object, just remember: pair a single <code>%...&gt;%</code> with a code block and you should be able to do almost anything.</p>
</div>
<div id="revisiting-the-data-reactive-progress-support" class="section level3">
<h3 class="hasAnchor">
<a href="#revisiting-the-data-reactive-progress-support" class="anchor"></a>Revisiting the <code>data</code> reactive: progress support</h3>
<p>Now that we have discussed a few techniques for writing async code, let’s come back to our original <code>data</code> event reactive, and this time do a more faithful async conversion that preserves the progress reporting functionality of the original.</p>
<p>Again, here’s the original sync code:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="co"># SYNCHRONOUS version</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2"></a>
<a class="sourceLine" id="cb22-3" data-line-number="3">data &lt;-<span class="st"> </span><span class="kw">eventReactive</span>(input<span class="op">$</span>date, {</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">  date &lt;-<span class="st"> </span>input<span class="op">$</span>date  <span class="co"># Example: 2018-05-28</span></a>
<a class="sourceLine" id="cb22-5" data-line-number="5">  year &lt;-<span class="st"> </span>lubridate<span class="op">::</span><span class="kw"><a href="http://lubridate.tidyverse.org/reference/year.html">year</a></span>(date)  <span class="co"># Example: "2018"</span></a>
<a class="sourceLine" id="cb22-6" data-line-number="6">  </a>
<a class="sourceLine" id="cb22-7" data-line-number="7">  url &lt;-<span class="st"> </span><span class="kw">glue</span>(<span class="st">"http://cran-logs.rstudio.com/{year}/{date}.csv.gz"</span>)</a>
<a class="sourceLine" id="cb22-8" data-line-number="8">  path &lt;-<span class="st"> </span><span class="kw">file.path</span>(<span class="st">"data_cache"</span>, <span class="kw">paste0</span>(date, <span class="st">".csv.gz"</span>))</a>
<a class="sourceLine" id="cb22-9" data-line-number="9">  </a>
<a class="sourceLine" id="cb22-10" data-line-number="10">  <span class="kw">withProgress</span>(<span class="dt">value =</span> <span class="ot">NULL</span>, {</a>
<a class="sourceLine" id="cb22-11" data-line-number="11">    </a>
<a class="sourceLine" id="cb22-12" data-line-number="12">    <span class="cf">if</span> (<span class="op">!</span><span class="kw">file.exists</span>(path)) {</a>
<a class="sourceLine" id="cb22-13" data-line-number="13">      <span class="kw">setProgress</span>(<span class="dt">message =</span> <span class="st">"Downloading data..."</span>)</a>
<a class="sourceLine" id="cb22-14" data-line-number="14">      <span class="kw">download.file</span>(url, path)</a>
<a class="sourceLine" id="cb22-15" data-line-number="15">    }</a>
<a class="sourceLine" id="cb22-16" data-line-number="16">    </a>
<a class="sourceLine" id="cb22-17" data-line-number="17">    <span class="kw">setProgress</span>(<span class="dt">message =</span> <span class="st">"Parsing data..."</span>)</a>
<a class="sourceLine" id="cb22-18" data-line-number="18">    <span class="kw">read_csv</span>(path, <span class="dt">col_types =</span> <span class="st">"Dti---c-ci"</span>, <span class="dt">progress =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb22-19" data-line-number="19"></a>
<a class="sourceLine" id="cb22-20" data-line-number="20">  })</a>
<a class="sourceLine" id="cb22-21" data-line-number="21">})</a></code></pre></div>
<p>Progress reporting currently presents two challenges for future.</p>
<p>First, the <code>withProgress({...})</code> function cannot be used with async. <code>withProgress</code> is designed to wrap a slow synchronous action, and dismisses its progress dialog when the block of code it wraps is done executing. Since the call to <code><a href="http://www.rdocumentation.org/packages/future/topics/future">future()</a></code> will return immediately even though the actual task is far from done, using <code>withProgress</code> won’t work; the progress dialog would be dismissed before the download even got going.</p>
<p>It’s conceivable that <code>withProgress</code> could gain promise compatibility someday, but it’s not in Shiny v1.1.0. In the meantime, we can work around this by using the alternative, <a href="https://shiny.rstudio.com/reference/shiny/1.1.0/Progress.html">object-oriented progress API</a> that Shiny offers. It’s a bit more verbose and fiddly than <code>withProgress</code>/<code>setProgress</code>, but it is flexible enough to work with futures/promises.</p>
<p>Second, progress messages can’t be sent from futures. This is simply because futures are executed in child processes, which don’t have direct access to the browser like the main Shiny process does.</p>
<p>It’s conceivable that <code>future</code> could gain the ability for child processes to communicate back to their parents, but no good solution exists at the time of this writing. In the meantime, we can work around this by taking the one future that does both downloading and parsing, and splitting it into two separate futures. After the download future has completed, we can send a progress message that parsing is beginning, and then start the parsing future.</p>
<p>The regrettably complicated solution is below.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="co"># ASYNCHRONOUS version</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2"></a>
<a class="sourceLine" id="cb23-3" data-line-number="3">data &lt;-<span class="st"> </span><span class="kw">eventReactive</span>(input<span class="op">$</span>date, {</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">  date &lt;-<span class="st"> </span>input<span class="op">$</span>date  </a>
<a class="sourceLine" id="cb23-5" data-line-number="5">  year &lt;-<span class="st"> </span>lubridate<span class="op">::</span><span class="kw"><a href="http://lubridate.tidyverse.org/reference/year.html">year</a></span>(date)</a>
<a class="sourceLine" id="cb23-6" data-line-number="6">  </a>
<a class="sourceLine" id="cb23-7" data-line-number="7">  url &lt;-<span class="st"> </span><span class="kw">glue</span>(<span class="st">"http://cran-logs.rstudio.com/{year}/{date}.csv.gz"</span>)</a>
<a class="sourceLine" id="cb23-8" data-line-number="8">  path &lt;-<span class="st"> </span><span class="kw">file.path</span>(<span class="st">"data_cache"</span>, <span class="kw">paste0</span>(date, <span class="st">".csv.gz"</span>))</a>
<a class="sourceLine" id="cb23-9" data-line-number="9">  </a>
<a class="sourceLine" id="cb23-10" data-line-number="10">  p &lt;-<span class="st"> </span>Progress<span class="op">$</span><span class="kw">new</span>()</a>
<a class="sourceLine" id="cb23-11" data-line-number="11">  p<span class="op">$</span><span class="kw">set</span>(<span class="dt">value =</span> <span class="ot">NULL</span>, <span class="dt">message =</span> <span class="st">"Downloading data..."</span>)</a>
<a class="sourceLine" id="cb23-12" data-line-number="12">  <span class="kw"><a href="http://www.rdocumentation.org/packages/future/topics/future">future</a></span>({</a>
<a class="sourceLine" id="cb23-13" data-line-number="13">    <span class="cf">if</span> (<span class="op">!</span><span class="kw">file.exists</span>(path)) {</a>
<a class="sourceLine" id="cb23-14" data-line-number="14">      <span class="kw">download.file</span>(url, path)</a>
<a class="sourceLine" id="cb23-15" data-line-number="15">    }</a>
<a class="sourceLine" id="cb23-16" data-line-number="16">  }) <span class="op">%...&gt;%</span></a>
<a class="sourceLine" id="cb23-17" data-line-number="17"><span class="st">    </span>{ p<span class="op">$</span><span class="kw">set</span>(<span class="dt">message =</span> <span class="st">"Parsing data..."</span>) } <span class="op">%...&gt;%</span></a>
<a class="sourceLine" id="cb23-18" data-line-number="18"><span class="st">    </span>{ <span class="kw"><a href="http://www.rdocumentation.org/packages/future/topics/future">future</a></span>(<span class="kw">read_csv</span>(path, <span class="dt">col_types =</span> <span class="st">"Dti---c-ci"</span>, <span class="dt">progress =</span> <span class="ot">FALSE</span>)) } <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb23-19" data-line-number="19"><span class="st">    </span><span class="kw"><a href="../reference/then.html">finally</a></span>(<span class="op">~</span>p<span class="op">$</span><span class="kw">close</span>())</a>
<a class="sourceLine" id="cb23-20" data-line-number="20">})</a></code></pre></div>
<p>The single future we wrote earlier has now become a pipeline of promises:</p>
<ol style="list-style-type: decimal">
<li>future (download)</li>
<li>send progress message</li>
<li>future (parse)</li>
<li>dismiss progress dialog</li>
</ol>
<p>Note that neither the R6 call <code>p$set(message = ...)</code> nor the second <code><a href="http://www.rdocumentation.org/packages/future/topics/future">future()</a></code> call are tidy, so they use curly-brace blocks, as discussed in the above section about <code>biggest_whales</code>.</p>
<p>The final step of dismissing the progress dialog doesn’t use <code>%...&gt;%</code> at all; because we want the progress dialog to dismiss whether the download and parse operations succeed or fail, we use the regular pipe <code>%&gt;%</code> and <code><a href="../reference/then.html">finally()</a></code> function instead. See the relevant section in <a href="https://rstudio.github.io/promises/articles/overview.html#cleaning-up-with-finally"><em>Working with promises in R</em></a> to learn more.</p>
<p>With these changes in place, we’ve now covered all of the changes to the application. You can see the full changes side-by-side via <a href="https://github.com/rstudio/cranwhales/compare/sync...async?diff=split">this GitHub diff</a>.</p>
</div>
</div>
<div id="measuring-scalability" class="section level2">
<h2 class="hasAnchor">
<a href="#measuring-scalability" class="anchor"></a>Measuring scalability</h2>
<p>It was a fair amount of work to do the sync-to-async conversion. Now we’d like to know if the conversion to async had the desired effect: improved responsiveness (i.e. lower latency) when the number of simultaneous visitors increases.</p>
<div id="load-testing-with-shiny-coming-soon" class="section level3">
<h3 class="hasAnchor">
<a href="#load-testing-with-shiny-coming-soon" class="anchor"></a>Load testing with Shiny (coming soon)</h3>
<p>At the time of this writing, we are working on a suite of load testing tools for Shiny that is not publicly available yet, but was previewed by Sean Lopp during his <a href="https://www.rstudio.com/resources/videos/scaling-shiny/">epic rstudio::conf 2018 talk</a> about running a Shiny load test with 10,000 simulated concurrent users.</p>
<p>You use these tools to easily <strong>record</strong> yourself using your Shiny app, which creates a test script; then <strong>play back</strong> that test script, but multiplied by dozens/hundreds/thousands of simulated concurrent users; and finally, <strong>analyze</strong> the timing data generated during the playback step to see what kind of latency the simulated users experienced.</p>
<p>To examine the effects of my async refactor, I recorded a simple test script by loading up the app, waiting for the first tab to appear, then clicking through each of the other tabs, pausing for several seconds each time before moving on to the next. When using the app without any other visitors, the homepage fully loads in less than a second, and the initial loading of data and rendering of the plot on the default tab takes about 7 seconds. After that, each tab takes no more than a couple of seconds to load. Overall, the entire test script, including time where the user is thinking, takes about 40 seconds under ideal settings (i.e. only a single concurrent user).</p>
<p>I then used this test script to generate load against the Shiny app running in my local RStudio. With the settings I chose, the playback tool introduced one new “user” session every 5 seconds, until 50 sessions total had been launched; then it waited until all the sessions were complete. I ran this test on both the sync and async versions in turn, which generated the following results.</p>
</div>
<div id="sync-vs-async-performance" class="section level3">
<h3 class="hasAnchor">
<a href="#sync-vs-async-performance" class="anchor"></a>Sync vs. async performance</h3>
<p><img src="case-study-gantt1.png"></p>
<p>In this plot, each row represents a single session, and the x dimension represents time. Each of the rectangles represents a single “step” in the test script, be it downloading the HTML for the homepage, fetching one of the two dozen JavaScript/CSS files, or waiting for the server to update outputs. So the wider a rectangle is, the longer the user had to wait.</p>
<p>Of particular importance are the red and pink rectangles, as these represent the initial page load. While these are taking place, the user is staring at a blank page, probably wondering if the server is down. Long waits during this stage are not only undesirable, but surprising and incomprehensible; whereas the user might be prepared to wait a little while for a complicated chart involving millions of rows of data to be rendered in response to an input change.</p>
<p>And as you can see from this plot, the behavior of the async app is much improved in homepage/JS/CSS loading time. The sync version of the app starts displaying unacceptably long red/pink loading times as early as session 10, and by session #40 the maximum page load time has exceeded two minutes. The async version at that point is showing 40 second load times, which is not great, but still a huge improvement. Judging by page load time alone, the async branch can support 3X the number of concurrent users.</p>
<p>I was surprised, though, to see that the blue areas of the chart were showing noticeably more latency for async than for sync.</p>
<p>There are several reasons for this, but one is that the slow page load times for the sync version actually ends up limiting the number of sessions that are contending to perform expensive computations. If you draw a vertical line anywhere through one of the Gantt charts, the number of blue rectangles you intersect represents the amount of concurrent sessions that are actively trying to do work on the server side.</p>
<p><img src="case-study-gantt2.png"></p>
<p>Notice that the large swaths of red and pink on the left limit the height of the blue “skyscraper” I’ve highlighted in yellow, while on the right, the skyscrapers get both taller (more contention) and wider (more latent). Due to the way this load test is structured, the async version’s efficiency in loading the homepage means it’s “rewarded” by having more contention on the server side. Taken in aggregate, though, the async version ultimately runs each session faster from start to finish, and also finishes the full 50-session test run about a minute sooner.</p>
</div>
<div id="further-optimizations" class="section level3">
<h3 class="hasAnchor">
<a href="#further-optimizations" class="anchor"></a>Further optimizations</h3>
<p>But why isn’t it faster still? The sync version does all of its work on a single thread, and I specifically designed this app to be a nightmare for scalability by having each session kick off by parsing hundreds of megabytes of CSV, an operation that takes several long seconds. The async version gets to spread these jobs across seven different workers. Why aren’t we seeing a greater time savings?</p>
<p>First, calling <code><a href="http://www.rdocumentation.org/packages/future/topics/future">future(read_csv("big_file.csv"))</a></code> is a bit of a worst-case scenario for future and async. <code>read_csv</code> is generally fast, but because the CRAN log files are so big, <code>read_csv("big_file.csv")</code> is slow. The value it returns is a very large data frame, that has now been loaded not into the Shiny process, but a <code>future</code> worker process. In order to return that data frame to the Shiny process, that data must first be serialized (I believe <code>future</code> essentially uses <code>saveRDS</code> for this), transmitted to the Shiny process, and then deserialized; to make matters worse, the transmitting and deserialization steps happen on the main R thread that we’re working so hard to try to keep idle. With all this extra overhead, it’s not that futures have <em>no</em> value here, as we’ve seen, but it’s definitely not ideal.</p>
<p>This is where we have to start asking ourselves what’s important to us. Both the sync and async versions of this app were written to be as idiomatic, simple, and clear as possible. Computer scientists love to talk about <a href="https://en.wikipedia.org/wiki/Space%E2%80%93time_tradeoff">space-time tradeoffs</a>, but just as common in my experience is a tradeoff between elegance and performance, and that goes double where functional programming is concerned.</p>
<p>In our case, our current code has an elegant design that’s easy to understand: the <code>data</code> reactive provides all the rows, which the other reactives and outputs are free to subset and aggregate however they want. We can probably make our code significantly faster by doing more summarizing, aggregation, and filtering inside the future; not only does this make more of the work happen in parallel, but by returning the data in already-processed form, we can have much less data to transfer from the worker process back to the Shiny process. (For example, the data for May 31, 2018 weighs 75MB before optimization, and 8.8MB afterwards.)</p>
<p>You can see the results below, as “async2”:</p>
<p><img src="case-study-gantt3.png"></p>
<p>The homepage load times have dropped further, and the calculation times are now as fast or faster than the sync code pretty much across the board. The overall test completion time has dropped by an additional minute compared to our previous effort.</p>
<p>Note also that the maximum “skyscraper height” has gone down, not up, as might’ve been expected. While the sync version’s effective concurrency was limited because of long page load times, the reason for async2 is the opposite: sessions are finishing more quickly than before, so they aren’t stacking up as much. In other words, the sync version’s sessions are slow to come in through the front door, while async2’s sessions are quick to leave through the back.</p>
<p>Take a look at the <a href="https://github.com/rstudio/cranwhales/compare/async...async2?diff=split">code diff for async vs. async2</a>. While the code has not changed very dramatically, it has lost a little elegance and maintainability: the code for each of the affected outputs now has one foot in the the render function and one foot in the future. If your app’s total audience is a team of a hundred analysts and execs, you may choose to forgo the extra performance and stick with the original async (or even sync) code. But if you have serious scaling needs, the refactoring is probably a small price to pay.</p>
<p>Let’s get real for a second, though. If this weren’t an example app written for exposition purposes, but a real production app that was intended to scale to thousands of concurrent users across dozens of R processes, we wouldn’t download and parse CSV files on the fly. Instead, we’d establish a proper <a href="http://solutions.rstudio.com/twitter_etl/">ETL procedure</a> to run every night and put the results into a properly indexed database table, or RDS files with just the data we need.</p>
<p>At this point, the clear majority of the latency for the async2 branch is from ggplot2 plotting. <a href="https://www.rstudio.com/resources/videos/scaling-shiny/">Sean’s talk</a> alluded to some upcoming plot caching features we’re adding to Shiny, and I imagine they would have as dramatic an effect for this test as they did for Sean.</p>
</div>
</div>
<div id="summing-up" class="section level2">
<h2 class="hasAnchor">
<a href="#summing-up" class="anchor"></a>Summing up</h2>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#motivation">Motivation</a></li>
      <li><a href="#our-source-data">Our source data</a></li>
      <li><a href="#a-tour-of-the-app">A tour of the app</a></li>
      <li><a href="#the-implementation">The implementation</a></li>
      <li><a href="#converting-to-async">Converting to async</a></li>
      <li><a href="#measuring-scalability">Measuring scalability</a></li>
      <li><a href="#summing-up">Summing up</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Joe Cheng, <a href="https://www.rstudio.com"><img src="https://tidyverse.org/rstudio-logo.svg" height="24"></a>.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://pkgdown.r-lib.org/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  </body>
</html>
